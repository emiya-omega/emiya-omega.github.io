[{"content":"","date":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":null,"permalink":"/tags/ds/","section":"Tags","summary":"","title":"DS"},{"content":"","date":null,"permalink":"/ds/","section":"DSes","summary":"","title":"DSes"},{"content":"","date":null,"permalink":"/","section":"House of Eternity","summary":"","title":"House of Eternity"},{"content":"","date":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":null,"permalink":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","section":"Categories","summary":"","title":"学习笔记"},{"content":"线性表的基本概念 #线性表的定义 # 线性表：具有相同特性的数据元素的有限序列 线性表中的数据元素称为元素 线性表中的数据元素个数称为线性表的长度，用n表示，n大于等于0，当n=0时，称为空表 A=(a1,a2,a3,...,an) 线性表中的数据元素ai(1\u0026lt;=i\u0026lt;=n)称为线性表中的第i个元素，ai的序号i称为元素ai在线性表中的位置 线性表中的第一个元素a1没有前驱，最后一个元素an没有后继，其余元素ai(2\u0026lt;=i\u0026lt;=n-1)既有前驱ai-1，也有后继ai+1 线性表中的数据元素之间是一对一的关系 线性表的抽象数据类型 #ADT List{ 数据对象：D={ai|ai∈ElemSet,i=1,2,...,n,n\u0026gt;=0} 数据关系：R1={\u0026lt;ai-1,ai\u0026gt;|ai-1,ai∈D,i=2,3,...,n} 基本操作： InitList(\u0026amp;L); DestroyList(\u0026amp;L); ClearList(\u0026amp;L); ListEmpty(L); ListLength(L); GetElem(L,i,\u0026amp;e); LocateElem(L,e); PriorElem(L,e,\u0026amp;pre_e); NextElem(L,e,\u0026amp;next_e); }ADT List 线性表的顺序表示和实现 # 线性表的顺序表示又称为顺序存储结构或顺序映像 用一组地址连续的存储单元依次存储线性表中的数据元素，从而使得线性表中在逻辑结构上相邻的数据元素在物理存储位置上也相邻 顺序存储的线性表称为顺序表 顺序表的结构体定义 #define MaxSize 50 typedef struct{ ElemType data[MaxSize]; int length; }SqList; 顺序表的基本操作 //初始化线性表 void InitList(SqList \u0026amp;L){ for(int i=0;i\u0026lt;MaxSize;i++){ L.data[i]=0; } L.length=0; } //插入操作 bool ListInsert(SqList \u0026amp;L,int i,ElemType e){ if(i\u0026lt;1||i\u0026gt;L.length+1){ return false; } if(L.length\u0026gt;=MaxSize){ } for(int j=L.length;j\u0026gt;=i;j--){ L.data[j]=L.data[j-1]; } L.data[i-1]=e; L.length++; return true; } //删除操作 bool ListDelete(SqList \u0026amp;L,int i,ElemType \u0026amp;e){ if(i\u0026lt;1||i\u0026gt;L.length){ return false; } e=L.data[i-1]; for(int j=i;j\u0026lt;L.length;j++){ L.data[j-1]=L.data[j]; } L.length--; return true; } //按位查找操作 ElemType GetElem(SqList L,int i){ return L.data[i-1]; } //按值查找操作 int LocateElem(SqList L,ElemType e){ for(int i=0;i\u0026lt;L.length;i++){ if(L.data[i]==e){ return i+1; } } return 0; } 线性表的链式表示和实现 # 线性表的链式表示又称为链式存储结构\n用一组任意的存储单元存储线性表中的数据元素，这组存储单元可以是连续的，也可以是不连续的\n链式存储的线性表称为链表\n链表中的数据元素称为结点，每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储数据元素直接后继位置的指针域\n结点结构体定义\ntypedef struct LNode{ ElemType data; struct LNode *next; }LNode,*LinkList; 链表的基本操作 //初始化链表 void InitList(LinkList \u0026amp;L){ L=(LinkList)malloc(sizeof(LNode)); L-\u0026gt;next=NULL; } //按位查找操作 LNode *GetElem(LinkList L,int i){ int j=1; LNode *p=L-\u0026gt;next; if(i==0){ return L; } if(i\u0026lt;1){ return NULL; } while(p!=NULL\u0026amp;\u0026amp;j\u0026lt;i){ p=p-\u0026gt;next; j++; } return p; } //按值查找操作 LNode *LocateElem(LinkList L,ElemType e){ LNode *p=L-\u0026gt;next; while(p!=NULL\u0026amp;\u0026amp;p-\u0026gt;data!=e){ p=p-\u0026gt;next; } return p; } //插入操作 bool ListInsert(LinkList \u0026amp;L,int i,ElemType e){ LNode *p=GetElem(L,i-1);//找到第i-1个结点 if(p==NULL){ return false; } LNode *s=(LNode *)malloc(sizeof(LNode)); s-\u0026gt;data=e; s-\u0026gt;next=p-\u0026gt;next; p-\u0026gt;next=s; return true; } //删除操作 bool ListDelete(LinkList \u0026amp;L,int i,ElemType \u0026amp;e){ LNode *p=GetElem(L,i-1); if(p==NULL){ return false; } LNode *q=p-\u0026gt;next; e=q-\u0026gt;data; p-\u0026gt;next=q-\u0026gt;next; free(q); return true; } 建立单链表 # 头插法 void CreateList_H(LinkList \u0026amp;L,int n){ L=(LinkList)malloc(sizeof(LNode)); L-\u0026gt;next=NULL; for(int i=0;i\u0026lt;n;i++){ LNode *p=(LNode *)malloc(sizeof(LNode)); scanf(\u0026#34;%d\u0026#34;,\u0026amp;p-\u0026gt;data); p-\u0026gt;next=L-\u0026gt;next; L-\u0026gt;next=p; } } 尾插法 void CreateList_L(LinkList \u0026amp;L,int n){ L=(LinkList)malloc(sizeof(LNode)); L-\u0026gt;next=NULL; LNode *r=L; for(int i=0;i\u0026lt;n;i++){ LNode *p=(LNode *)malloc(sizeof(LNode)); scanf(\u0026#34;%d\u0026#34;,\u0026amp;p-\u0026gt;data); r-\u0026gt;next=p; r=p; } r-\u0026gt;next=NULL; } 双向链表 # 双向链表的结构体定义 typedef struct DNode{ ElemType data; struct DNode *prior,*next; }DNode,*DLinkList; 双向链表的基本操作 //初始化双向链表 void InitDList(DLinkList \u0026amp;L){ L=(DLinkList)malloc(sizeof(DNode)); L-\u0026gt;prior=NULL; L-\u0026gt;next=NULL; } //按位查找操作 DNode *GetElem(DLinkList L,int i){ int j=1; DNode *p=L-\u0026gt;next; if(i==0){ return L; } if(i\u0026lt;1){ return NULL; } while(p!=NULL\u0026amp;\u0026amp;j\u0026lt;i){ p=p-\u0026gt;next; j++; } return p; } //按值查找操作 DNode *LocateElem(DLinkList L,ElemType e){ DNode *p=L-\u0026gt;next; while(p!=NULL\u0026amp;\u0026amp;p-\u0026gt;data!=e){ p=p-\u0026gt;next; } return p; } //插入操作 bool ListInsert(DLinkList \u0026amp;L,int i,ElemType e){ DNode *p=GetElem(L,i-1);//找到第i-1个结点 if(p==NULL){ return false; } DNode *s=(DNode *)malloc(sizeof(DNode)); s-\u0026gt;data=e; s-\u0026gt;next=p-\u0026gt;next; s-\u0026gt;prior=p; if(p-\u0026gt;next!=NULL){ p-\u0026gt;next-\u0026gt;prior=s; } p-\u0026gt;next=s; return true; } //删除操作 bool ListDelete(DLinkList \u0026amp;L,int i,ElemType \u0026amp;e){ DNode *p=GetElem(L,i-1); if(p==NULL){ return false; } DNode *q=p-\u0026gt;next; e=q-\u0026gt;data; p-\u0026gt;next=q-\u0026gt;next; if(q-\u0026gt;next!=NULL){ q-\u0026gt;next-\u0026gt;prior=p; } free(q); return true; } 线性表的顺序表示和链式表示的比较 # 顺序表 优点：可以随机存取，存储密度高 缺点：大片连续空间分配不方便，改变容量不方便 链表 优点：离散的小空间分配方便，改变容量方便 缺点：不可随机存取，存储密度低 线性表的应用 #线性表的合并 # 假设线性表La和Lb分别表示两个集合A和B，现要求一个新的集合A∪B 合并操作 void unionL(LList \u0026amp;La,LList Lb){ int La_len=Llength(La); int Lb_len=Llength(Lb); for(int i=1;i\u0026lt;=Lb_len;i++){ ElemType e; GetElem(Lb,i,e); if(!LocateElem(La,e)){ ListInsert(La,++La_len,e); } } } 静态链表 # 静态链表的结构体定义 #define MaxSize 50 typedef struct{ ElemType data; int next; }SLinkList[MaxSize]; 静态链表的基本操作 //初始化静态链表 void InitList(SLinkList \u0026amp;L){ for(int i=0;i\u0026lt;MaxSize-1;i++){ L[i].next=i+1; } L[MaxSize-1].next=0; } //按位查找操作 int GetElem(SLinkList L,int i){ if(i\u0026lt;1||i\u0026gt;MaxSize){ return 0; } return L[i].next; } //按值查找操作 int LocateElem(SLinkList L,ElemType e){ int i=1; while(i!=0\u0026amp;\u0026amp;L[i].data!=e){ i=L[i].next; } return i; } //插入操作 bool ListInsert(SLinkList \u0026amp;L,int i,ElemType e){ int j=GetElem(L,0); int k=0; for(int l=1;l\u0026lt;i;l++){ k=j; j=L[j].next; } int q=GetElem(L,0); L[0].next=j; L[j].next=q; L[k].next=i; L[i].data=e; L[i].next=q; return true; } //删除操作 bool ListDelete(SLinkList \u0026amp;L,int i,ElemType \u0026amp;e){ int j=GetElem(L,0); int k=0; for(int l=1;l\u0026lt;i;l++){ k=j; j=L[j].next; } int q=L[j].next; e=L[j].data; L[j].next=L[q].next;//将q结点从链表中断开 L[q].next=GetElem(L,0);//回收结点q L[0].next=j; return true; } 静态链表的使用跟顺序表一样，都需要预先分配较大的空间 在进行插入删除操作时，只需要改变指针的指向，不需要移动元素，所以时间复杂度为O(1) 静态链表也可以用于解决哈希冲突问题 循环链表 # 循环链表的结构体定义 typedef struct LNode{ ElemType data; struct LNode *next; }LNode,*LinkList; 循环链表的基本操作 //初始化循环链表 void InitList(LinkList \u0026amp;L){ L=(LinkList)malloc(sizeof(LNode)); L-\u0026gt;next=L; } //按位查找操作 LNode *GetElem(LinkList L,int i){ int j=1; LNode *p=L-\u0026gt;next; if(i==0){ return L; } if(i\u0026lt;1){ return NULL; } while(p!=L\u0026amp;\u0026amp;j\u0026lt;i){ p=p-\u0026gt;next; j++; } return p; } //按值查找操作 LNode *LocateElem(LinkList L,ElemType e){ LNode *p=L-\u0026gt;next; while(p!=L\u0026amp;\u0026amp;p-\u0026gt;data!=e){ } } //插入操作 bool ListInsert(LinkList \u0026amp;L,int i,ElemType e){ LNode *p=GetElem(L,i-1); if(p == NULL){ return false; } LNode *s=(LNode *)malloc(sizeof(LNode)); s-\u0026gt;data=e; s-\u0026gt;next=p-\u0026gt;next; p-\u0026gt;next=s; return true; } //删除操作 bool ListDelete(LinkList \u0026amp;L,int i,ElemType \u0026amp;e){ LNode *p=GetElem(L,i-1); if(p==NULL){ return false; } LNode *q=p-\u0026gt;next; e=q-\u0026gt;data; p-\u0026gt;next=q-\u0026gt;next; free(q); return true; } 特点 表中最后一个结点的指针指向头结点而不再是NULL，整个链表形成一个环 从表中任一结点出发均可找到链表中的其他结点 循环链表可以避免单链表判空操作 循环链表的最后一个结点的next指针指向头结点 循环链表可以用来解决约瑟夫环问题 有序表 #有序表定义 # 有序表是一种线性表，其元素是按关键字有序排列的 所有元素以递增or递减方式有序排列的线性表称为有序表 有序表和线性表的逻辑结构相同，区别是个别运算不同 以顺序结构进行存储时，其中只有ListInsert()基本运算有所差异，其余基本相同。 有序顺序表的ListInsert()运算 void ListInsert(SqList \u0026amp;L,int i,ElemType e){ int j; for(j=L.length;j\u0026gt;=i;j--){ L.data[j]=L.data[j-1]; } L.data[i-1]=e; L.length++; } 有序表的查找 # 有序表的查找 二分查找 插值查找 斐波那契查找 二分查找 假设有序表为L，要查找的元素为e，L的长度为n，则查找过程如下： 取L的中间元素L[mid]，如果L[mid]==e，则查找成功，返回mid 如果L[mid]\u0026gt;e，则在L的左半部分继续查找 如果L[mid]\u0026lt;e，则在L的右半部分继续查找 TBD #","date":"14 September 2024","permalink":"/ds/list/","section":"DSes","summary":"","title":"线性表"},{"content":"","date":null,"permalink":"/cpp/","section":"CPPs","summary":"","title":"CPPs"},{"content":"","date":null,"permalink":"/tags/cpp/","section":"Tags","summary":"","title":"CPP"},{"content":"静态成员 #静态数据成员 # 在一个类中,若将一个数据成员说明为static，这种成员称为静态数据成员。 与一般的数据成员不同，无论建立多少个类的对象，都只有一个静态数据的拷贝。从而实现了同一个类的不同对象之间的数据共享。 定义静态数据成员的格式如下: static 数据类型 数据成员名;\n说明 # 静态数据成员的定义要加上关键字static ； 静态数据成员的初始化应在类声明之后， 定义对象之前，在类外单独进行。初始化格式为: 数据类型 类名::静态数据成员名 = 初始值\n静态数据成员属于类，而不像普通数据成员那样属于某一对象。因此可以使用以下方式访问静态数据成员: 类名::静态数据成员名 如上例中的: Student::count和Student::sum\n静态数据成员与静态变量一样, 在编译时创建并初始化。 它在该类的任何对象被建立之前就存在。因此, 公有的静态数据成员可以在对象定义之前被访问。对象定义后，也可以通过对象访问公有的静态数据成员，访问格式为: 对象名.静态数据成员名 对象指针-\u0026gt;静态数据成员名\n私有静态数据成员不能被类外部函数访问, 也不能用对象进行访问。 C++支持静态数据成员的一个主要原因是可以不必使用全局变量。依赖于全局变量的类几乎都是违反面向对象程序设计的封装原理。 静态成员函数 # 静态成员函数属于整个类, 是该类所有成员共享的成员函数。定义静态成员函数的格式如下: static 返回类型 静态成员函数名（参数表）;\n与静态数据成员类似,调用公有静态成员函数的一般格式有如下几种: 类名::静态成员函数名(实参表) 对象. 静态成员函数名(实参表) 对象指针-\u0026gt;静态成员函数名(实参表)\n说明 # 一般情况下，静态成员函数主要用来访问全局变量or同一类中的静态数据成员 私有静态成员函数不能被类外部函数和对象访问 静态成员函数可在建立任何对象之前处理静态数据成员，普通成员函数则不能 编译系统将静态成员函数限定为内部连接，也就是与现行文件相连接的其它文件中的同名函数不会与该函数冲突（因编译器而异） 在一般的成员函数中都隐含一个this指针, 用来指向对象本身, 而静态成员函数则没有this指针 静态成员函数一般不访问类中的非静态成员。若确实需要，静态成员函数只能通过对象名(或指向对象的指针)访问非静态成员 cout \u0026lt;\u0026lt; “一只小猫的重量是：” \u0026lt;\u0026lt; weight \u0026lt;\u0026lt; “千克\\n”; //不合法，weight是非静态数据成员 cout \u0026lt;\u0026lt; “小猫的总重量是” \u0026lt;\u0026lt; total_weight \u0026lt;\u0026lt; “千克” \u0026lt;\u0026lt; endl; //合法，total_weight是静态数据成员 若需要访问非静态数据成员，则只能通过对象名。 如：把display函数定义为静态成员函数时，可将对象的引用作为函数参数，将它定义为： static void display (Small_cat \u0026amp;w) cout \u0026laquo; “这只小猫的重量是：” \u0026laquo; w.weight \u0026laquo; “千克\\n”;\n友元 #友元函数 # 将非成员函数声明为友元函数 友元函数不是当前类的成员函数, 而是独立于当前类的外部函数, 但它可以访问该类的所有对象的成员, 包括私有成员、保护成员和公有成员。\n说明 # 友元函数不是成员函数, 在类外部定义友元函数时不必在函数名前加上“类名::”。\n友元函数不是类的成员，它需通过作为入口参数传递进来的对象名去访问引用该对象的数据成员。\ncout \u0026lt;\u0026lt; “女孩的姓名是：” \u0026lt;\u0026lt; x.name; //合法 cout \u0026lt;\u0026lt; “女孩的姓名是：” \u0026lt;\u0026lt; name; //不合法 当一个函数需要访问多个类时，友元函数就显得非常重要。 使用友元函数虽然提高了效率， 但与面向对象的程序设计思想相背，应当谨慎使用。 将成员函数声明为友元函数 # 一个类的成员函数也可以作为另一个类的友元，这种成员函数不仅可以访问自己所在类对象中的所有成员, 还可以访问friend声明语句所在类对象中的所有成员。这样能使两个类相互合作、协调工作,完成某一任务。 友元类 # 一个类作为另一个类的友元 格式 friend　类名；\nclass Y{ ..... }; class X{ ..... friend Y; ..... }; 当类Y被说明为类X的友元时，类Y的所有成员函数都成为类X的友元函数。这就意味着：作为友元类Y中的所有成员函数都可以访问类X中的所有成员（包括私有成员）。 友元关系是单向的，不具备交换性 友元关系不具有传递性 类的组合 # 如有以下的组合类: class X{ 类名1 对象成员名1; 类名2 对象成员名2; … 类名n 对象成员名n; }; 则类X的构造函数的定义形式为;\nX::X(对象成员所需的形参，本类成员形参): 对象成员名1(形参表1),…,对象成员名n(形参表n) { // …构造函数体 } 如有以下的组合类 Student::Student(string name1, string stu_no1, float s1, float s2, float s3): score1(s1, s2, s3)\n构造函数调用顺序 先调用内嵌对象的构造函数（按内嵌时的声明顺序，先声明者先构造）。然后调用本类的构造函数。（析构函数的调用顺序相反） 对上面的代码段而言：先调用对象成员score1的构造函数，再执行类Student的构造函数 ","date":"9 May 2024","permalink":"/cpp/6/","section":"CPPs","summary":"","title":"静态成员-友元函数-类的组合"},{"content":"string类 # string类的字符串对象的使用方法与其他对象一样，但必须先定义才可使用 定义格式 string str1,str2; string str3(\u0026#34;china\u0026#34;); 等价于 string str3=\u0026#34;china\u0026#34;; 向函数传递对象 #使用对象作为函数参数 # 向函数传递对象时,是通过\u0026quot;传值调用\u0026quot;传递给函数 因此,函数中对对象任何修改均不影响调用该函数对象的本身 #include \u0026lt;iostream\u0026gt; class Tr{ public: Tr(int n){ i=n; } void set(int n){ i=n; } int get(){ return i; } private: int i; }; void sqr(Tr ob){ ob.set(ob.get()*ob.get()); cout \u0026lt;\u0026lt;\u0026#34;在函数sqr内,形参对象ob的数据成员i的值为\u0026#34;\u0026lt;\u0026lt;ob.get()\u0026lt;\u0026lt;endl; } int main(){ Tr obj(10); cout\u0026lt;\u0026lt;\u0026#34;调用函数sqr前,实参i值为:\u0026#34;\u0026lt;\u0026lt;obj.get()\u0026lt;\u0026lt;endl; sqr(obj); cout\u0026lt;\u0026lt;\u0026#34;调用函数sqr后,实参i值为:\u0026#34;\u0026lt;\u0026lt;obj.get()\u0026lt;\u0026lt;endl; return 0; } output: 调用函数sqr前,实参i值为:10 在函数sqr内,形参对象ob的数据成员i的值为100 调用函数sqr后,实参i的值为:10\n使用对象指针作为函数参数 # 使用对象指针作为函数参数可以实现\u0026quot;传址调用\u0026quot;,即可在被调用函数中改变调用函数的参数对象的值 #include \u0026lt;iostream\u0026gt; class Tr{ public: Tr(int n){ i=n; } void set(int n){ i=n; } int get(){ return i; } private: int i; }; void sqr(Tr *ob){ ob-\u0026gt;set(ob-\u0026gt;get()*ob-\u0026gt;get()); cout \u0026lt;\u0026lt;\u0026#34;在函数sqr内,形参对象ob的数据成员i的值为\u0026#34;\u0026lt;\u0026lt;ob-\u0026gt;get()\u0026lt;\u0026lt;endl; } int main(){ Tr obj(10); cout\u0026lt;\u0026lt;\u0026#34;调用函数sqr前,实参i值为:\u0026#34;\u0026lt;\u0026lt;obj.get()\u0026lt;\u0026lt;endl; sqr(obj); cout\u0026lt;\u0026lt;\u0026#34;调用函数sqr后,实参i值为:\u0026#34;\u0026lt;\u0026lt;obj.get()\u0026lt;\u0026lt;endl; return 0; } output: 调用函数sqr前,实参i值为:10 在函数sqr内,形参对象ob的数据成员i的值为100 调用函数sqr后,实参i的值为:100\n使用对象引用作为函数参数 # 使用对象引用作为函数参数实现的也是\u0026quot;传址调用\u0026quot;,但比对象指针更简单,更直接,建议使用引用 #include \u0026lt;iostream\u0026gt; class Tr{ public: Tr(int n){ i=n; } void set(int n){ i=n; } int get(){ return i; } private: int i; }; void sqr(Tr \u0026amp;ob){ ob.set(ob.get()*ob.get()); cout \u0026lt;\u0026lt;\u0026#34;在函数sqr内,形参对象ob的数据成员i的值为\u0026#34;\u0026lt;\u0026lt;ob.get()\u0026lt;\u0026lt;endl; } int main(){ Tr obj(10); cout\u0026lt;\u0026lt;\u0026#34;调用函数sqr前,实参i值为:\u0026#34;\u0026lt;\u0026lt;obj.get()\u0026lt;\u0026lt;endl; sqr(obj); cout\u0026lt;\u0026lt;\u0026#34;调用函数sqr后,实参i值为:\u0026#34;\u0026lt;\u0026lt;obj.get()\u0026lt;\u0026lt;endl; return 0; } output: 调用函数sqr前,实参i值为:10 在函数sqr内,形参对象ob的数据成员i的值为100 调用函数sqr后,实参i的值为:100\n对象赋值语句 # A和B是同一类的两个对象,那么下述对象赋值语句,就能把对象A的数据成员的值逐位复制给对象B B=A; 拷贝构造函数 #调用拷贝构造函数的形式 # 代入法 类名 对象2(对象1) 如: Point p2(p1); 赋值法 对象2=对象1; 如:Point p2=p1; 缺省拷贝构造函数 # 如果没有编写自定义的拷贝构造函数,C P P会自动地将一个已存在的对象复制给新对象 这种按成员逐一复制的过程是由缺省拷贝构造函数自动完成的 调用构造函数的3种情况 # 当用类的一个对象去初始化该类的另一个对象时,拷贝构造函数将会被调用 如: Point p2(p1); Point p2=p1; 当函数的形参是类的对象,在调用函数进行形参和实参结合时,拷贝函数将会被调用 void fun1(Point p) { p.print(); } int main() { Point p1(10,20); fun1(p1); return 0; } 当函数的返回值是类的对象,在函数调用完毕将返回值(对象)带回函数调用处时,此时就会调用拷贝构造函数,将此对象复制给一个临时对象并传到该函数的调用处 Point fun2() { Point p1(10,30); return p1; } int main() { Point p2; p2 = fun2(); return 0; } ","date":"24 April 2024","permalink":"/cpp/5/","section":"CPPs","summary":"","title":"string类-向函数传递对象-对象赋值语句-拷贝构造函数"},{"content":"类的构造函数和析构函数 #构造函数 # 构造函数的名字必须与类名相同，且不能有返回参数 class Complex{ Private: double real; double imag; Public: Complex(double r,double i) {real=r;imag=i;} }; 定义对象时，编译系统会自动调用构造函数~~（初始化）~~ 与普通成员函数一样，可以定义在体内也可以定义在体外 构造函数的主要作用是对对象进行初始化 构造函数一般声明为公有成员，但不能像其他成员一样被显式调用它在定义对象的同时被调用，且只调用一次 在实际应用中有通常要为每一个类定义构造函数 构造函数可以不带参数 构造函数可以重载 用成员初始化列表对数据成员初始化 # 一般表达形式 类名::构造函数名([参数表])[:(成员初始化列表)] {//构造函数体} 成员初始化列表一般形式 数据成员1(初始值1),数据成员2(初始值2),\u0026hellip;..\n析构函数 # 定义 是一种特殊的成员函数，与构造函数功能相反，它用来释放对象，即当删除对象前，回收储存空间并进行一些清理工作 性质 析构函数名称与类名相同，但它名称前面必须要加一个～ 析构函数没有返回值，也没有参数 当对象生命周期结束时，编译系统会自动调用析构函数 析构函数不能重载 对象数组 # 指每一数组元素都是对象的数组 定义形式 类名 数组名 [下标表达式] Complex com[10] 有几个数组元素就要调用几次构造函数 如果构造函数只有一个参数，在定义对象数组时可以直接在等号后面的花括号内提供实参 使用格式 数组名[下标].成员名 当类中有多个参数的构造函数时，则必须使用如下的形式进行对象数组的初始化 Complex com[3]={ //定义对象数组com Complex(1.1,2.2),//为第一个对象数组元素提供实参 Complex(3.3,4,4),//为第二个对象数组元素提供实参 Complex(5.5,6.6)//为第三个对象数组元素提供实参 }; 对象指针 # 在CPP中，可以直接引用对象，也可通过指向该对象的指针引用对象 exe ob; //定义类exe的对象ob exe *p; //定义指向类exe的对象指针p P=\u0026amp;ob;//将对象ob的地址赋给对象指针p 用对象指针访问对象数组 exe ob[2];//定义类exe的对象数组ob[2] exe *p;//定义指向类exe的对象指针p //数组名代表第一个元素的地址 P=ob; //将对象数组ob的地址赋给对象指针p this指针 # 在每个对象的数据成员中都有一个系统隐含的指针this 这个指针this的类型为这个对象所属类的类型 这个指针this的值为包含它的那个对象的首地址 ","date":"18 April 2024","permalink":"/cpp/4/","section":"CPPs","summary":"","title":"构造函数－成员列表－析构函数－对象数组和对象指针"},{"content":"","date":null,"permalink":"/tags/%E6%95%B0%E7%94%B5/","section":"Tags","summary":"","title":"数电"},{"content":"逻辑代数公式 # 分配律 \\(A\\cdot(B+C)=A\\cdot B+A\\cdot C\\) \\(A+B \\cdot C=(A+B)\\cdot(A+C)\\) 同一律 \\(A\\cdot A=A\\) \\( A+A=A \\) 德摩根定理 \\(\\overline{A\\cdot B}=\\overline{A}+\\overline{B}\\) \\(\\overline{A+B}=\\overline{A}\\cdot \\overline{B}\\) 还原律 \\(\\overline{\\overline{A}}=A\\) 若干常用公式 \\(A\\cdot B+A\\cdot \\overline{B}=A\\) \\(A+A\\cdot B=A\\) \\(A+\\overline{A}\\cdot B=A+B\\) \\(A\\cdot B+\\overline{A}\\cdot C+B\\cdot C=A\\cdot B+\\overline{A}\\cdot C\\) 逻辑函数的最简表达式 #最简与或式 # 定义: 乘积项的个数最少,每个乘积项中相乘的变量个数也最少的与或表达式,称为最简与或式 最简与非-与非式 # 定义: 非号个数最少,每个非号下面相乘的变量个数也最少的与非-与非式,称为最简与非-与非式 求法: 在最简与或表达式的基础上,两次取反,再用德摩根定理去掉下面的反号,便可得到 最简或与式 # 定义: 括号个数最少,每个括号中相加的变量的个数也最少的或与式,称为最简或与式 求法: 在反函数最简与或式的基础上,取反,再用德摩根定理去掉反号,便可得到函数的最简或与式 最简或非-或非式 # 定义:非号个数最少,每个非号下面相加的变量个数也最少的或非-或非式,称为最简或非-或非表达式 求法:在最简或与表达式的基础上,两次取反,再用德摩根定理去掉下面的反号,所得到的便是函数的最简或非-或非表达式 最简与或非表达式 # 定义:在非号下面相加的乘积项个数最少,每个乘积项中相乘的变量个数也最少的与或非式,称为最简与或非表达式 求法:在最简或非-或非式的基础上,用德摩根定理去掉大反号下面的小反号,便可得到函数的最简与或非表达式 逻辑函数表示方法 #真值表 # 把变量的各种可能取值与相应的函数值,以表格形式一一列举出来. 列写方法: 0、1两种取值,n个变量共有\\(2^n\\)种不同的取值,将他们按二进制数递增规律排列起来,同时在相应位置写上函数的值,便可得到逻辑函数的真值表 卡诺图 # 定义：一个逻辑函数的卡诺图就是将此函数的最小项表达式中的各项最小项相应地填入一个特定的方格图内，此方格图为卡诺图 特点：几何位置相邻的最小项在逻辑上也是相邻的。即相邻的两个最小项只有一个变量不同 注意 对于n个变量的逻辑函数有 2ⁿ个最小项 卡诺图相邻的数为格雷编码，即只有一位二进制数不同（01-\u0026gt;11-\u0026gt;10） 逻辑表达式 # 用与、或、非等运算表示函数中各个变量之间逻辑关系的代数式子,称为逻辑表达式 逻辑图 # 用基本和常用的逻辑符号表示函数表达式中各个变量的运算关系 波形图 # 反映输入和输出变量对应取值随时间按照一定规律变化的图形,就称为波形图,也称时间图 ","date":"1 April 2024","permalink":"/cpp/3/","section":"CPPs","summary":"","title":"逻辑代数公式及最简表达式"},{"content":"k## 作用域运算符::\n说明 # 如果两个变量同名,一个全局的,一个局部的,那么局部变量在其作用域内具有较高的优先级 联合 #声明 #union data { int i; double d; }x; 访问时 x.i x.d 无名联合 # 是cpp中的特殊联合,它在关键字union后面没有给出联合名,它可使一组数据共用同一内存地址 结构体对齐\n强制类型转换 # OLD int i =10; float x=(float)i; NEW int 1=10; float x=float(i); new与delete运算符 #C语言内存动态分配 #int *p; p=(int*)malloc(sizeof(int)); free(p); CPP语言动态分配 #int *p; p=new int; delete p; 用法 # 用new申请空间的格式 p = new type; 用delete释放所申请的空间格式 delete p; 特殊用法 # 用new分配内存的同时,可以用()指定其初始值,但不能为数组元素指定初值 int *p; p = new int(99); 用new建立多维数组类型的变量 p=new type[size][m][n]...[s]; int (*pi)[3][4]=new int [i*4][3][4]; 用new可为动态数组分配内存空间 p=new float[5]; p=new int[m]; p=new double[m+5*n]; new和delete应该配对使用 #引用(CPP独占) # 引用相当于为某个变量、常量、数组或对象起了一个别名 使用 # 如果引用不是用作函数的参数或返回值,则必须在说明时初始化 int i; int \u0026amp;j; j=i; is ERROR\nint i; int \u0026amp;j=i; is RIGHT\n不是任何类型的数据都可以引用 不允许建立void类型的引用 不允许建立引用的数组 不能建立引用的引用;不能建立指向引用的指针; ","date":"29 March 2024","permalink":"/cpp/2/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/","section":"CPPs","summary":"","title":"作用域运算符-联合-强转-内存动态分配-引用"},{"content":"逗号语句执行 #printf(\u0026quot;%d\u0026quot;,(int a=3*5,a*4,a+5));\noutput\u0026gt;:20 在这个 printf 语句中，a=3 * 5 , a * 4,a+5 是一个逗号表达式。逗号表达式会依次计算其内部的子表达式，并返回最后一个子表达式的值。但是，逗号表达式的一个重要特性是，它会保证所有的子表达式（从左到右）都会被求值，并且除了最后一个子表达式的结果都会被丢弃\n带有默认(缺省)参数的函数 # 缺省函数必须从左往右定义,并且在一个缺省参数的右边不能有未指定的缺省值的参数. 定义 # 在函数定义or函数声明中指定了初始值的参数称为默认参数 int special(int x=5,float y=5.3); 初始化 # 可定义为任意的初始化表达式,可以包含函数调用以及全局变量等 int fun (int w=sqrt(a),int x=a*a); 说明 # void fun(int w,int x=1 ,int y=1,int z=1) is RIGHT\nvoid fun(int w,int x=1 ,int y, int z=1) is ERROR\n规则 # 如果函数定义在前,函数调用在后,在函数定义处写默认值 如果函数调用在前,函数定义在后,在函数声明处写默认值,函数定义处不要写 函数重载与默认值 #说明 # 缺省函数必须从右往左定义,并且在一个缺省参数的右边不能有未指定的缺省值的参数 void fun(int w,int x ,int y=1 ); void fun(int w,int x ); 该段代码有歧义若参数为 2,3 以上两种方式均合适产生二义性导致报错 ","date":"28 March 2024","permalink":"/cpp/1/%E9%80%97%E5%8F%B7%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C-%E9%BB%98%E8%AE%A4%E5%80%BC%E7%9B%B8%E5%85%B3/","section":"CPPs","summary":"","title":"逗号语句执行-默认值相关-函数重载"},{"content":"面向对象语言特点 # 抽象 类 -\u0026gt; 抽象 对象 -\u0026gt; 具体 封装 成员变量(私) 成员函数(公) 继承 多态 cpp向下兼容c语言 #cpp中不允许/**/嵌套使用 #cout\u0026lt;\u0026lt;_LINE_\u0026lt;\u0026lt;~~; # 显示该语句位于源程序第几行 通常只有规模很小(一般为1~5条语句)而频繁使用函数才定义为内联函数 #输出长度与精度控制 ##include \u0026lt;iomainip\u0026gt; //std::setw cout\u0026lt;\u0026lt;setw(10);限制输出长度为10 cout\u0026lt;\u0026lt;setprecision(5)\u0026lt;\u0026lt;~;//限制输出精度 cout\u0026lt;\u0026lt;fixed;//用定点数表示法表示浮点数 cpp中函数可以重载.只要函数参数的类型不同,or参数的个数不同,或者二者兼而有之,两个or两个以上的函数可以使用相同的函数名 #指向常量的指针 #const char *name =\u0026quot;chen\u0026quot;;\n*name 是常量(name不允许改变) name[3]='a' ; is ERROR name是指向常量的指针变量(指针name本身可以改变) name =\u0026quot;zhang\u0026quot;; is RIGHT 指向字符串的常指针 #char* const name =\u0026quot;chen\u0026quot;;\nname是常量(name不允许改变) 指针的地址不允许改变 name = \u0026quot;zhang\u0026quot; is ERROR 指向常量的常指针 #const char* const name =\u0026quot;chen\u0026quot;;\n","date":"28 March 2024","permalink":"/cpp/cpp%E7%89%B9%E7%82%B9-%E8%BE%93%E5%87%BA%E9%95%BF%E5%BA%A6%E4%B8%8E%E7%B2%BE%E5%BA%A6%E6%8E%A7%E5%88%B6-%E6%8C%87%E9%92%88%E4%B8%8E%E5%B8%B8%E9%87%8F/","section":"CPPs","summary":"","title":"CPP特点-输出长度与精度控制-指针与常量"},{"content":"本博客由22年部署现迁移至github+hugo #原地址：https://emiya-omega.gitlab.io 警告! 本博客不针对移动端进行页面优化! ","date":"27 March 2024","permalink":"/posts/test/test/","section":"Posts","summary":"","title":"About"},{"content":"","date":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":null,"permalink":"/tags/%E4%BB%8B%E7%BB%8D/","section":"Tags","summary":"","title":"介绍"},{"content":"","date":null,"permalink":"/categories/%E6%9D%82%E6%96%87/","section":"Categories","summary":"","title":"杂文"}]