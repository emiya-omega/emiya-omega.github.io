[{"content":"面向对象语言特点 # 抽象 类 -\u0026gt; 抽象 对象 -\u0026gt; 具体 封装 成员变量(私) 成员函数(公) 继承 多态 cpp向下兼容c语言 #cpp中不允许/**/嵌套使用 #cout\u0026lt;\u0026lt;_LINE_\u0026lt;\u0026lt;~~; # 显示该语句位于源程序第几行 通常只有规模很小(一般为1~5条语句)而频繁使用函数才定义为内联函数 #输出长度与精度控制 ##include \u0026lt;iomainip\u0026gt; //std::setw cout\u0026lt;\u0026lt;setw(10);限制输出长度为10 cout\u0026lt;\u0026lt;setprecision(5)\u0026lt;\u0026lt;~;//限制输出精度 cout\u0026lt;\u0026lt;fixed;//用定点数表示法表示浮点数 cpp中函数可以重载.只要函数参数的类型不同,or参数的个数不同,或者二者兼而有之,两个or两个以上的函数可以使用相同的函数名 #指向常量的指针 #const char *name =\u0026quot;chen\u0026quot;;\n*name 是常量(name不允许改变) name[3]='a' ; is ERROR name是指向常量的指针变量(指针name本身可以改变) name =\u0026quot;zhang\u0026quot;; is RIGHT 指向字符串的常指针 #char* const name =\u0026quot;chen\u0026quot;;\nname是常量(name不允许改变) 指针的地址不允许改变 name = \u0026quot;zhang\u0026quot; is ERROR 指向常量的常指针 #const char* const name =\u0026quot;chen\u0026quot;;\n","date":"28 March 2024","permalink":"/cpp/cpp%E7%89%B9%E7%82%B9-%E8%BE%93%E5%87%BA%E9%95%BF%E5%BA%A6%E4%B8%8E%E7%B2%BE%E5%BA%A6%E6%8E%A7%E5%88%B6-%E6%8C%87%E9%92%88%E4%B8%8E%E5%B8%B8%E9%87%8F/","section":"CPPs","summary":"面向对象语言特点 # 抽象 类 -\u0026gt; 抽象 对象 -\u0026gt; 具体 封装 成员变量(私) 成员函数(公) 继承 多态 cpp向下兼容c语言 #cpp中不允许/**/嵌套使用 #cout\u0026lt;\u0026lt;_LINE_\u0026lt;\u0026lt;~~; # 显示该语句位于源程序第几行 通常只有规模很小(一般为1~5条语句)而频繁使用函数才定义为内联函数 #输出长度与精度控制 ##include \u0026lt;iomainip\u0026gt; //std::setw cout\u0026lt;\u0026lt;setw(10);限制输出长度为10 cout\u0026lt;\u0026lt;setprecision(5)\u0026lt;\u0026lt;~;//限制输出精度 cout\u0026lt;\u0026lt;fixed;//用定点数表示法表示浮点数 cpp中函数可以重载.","title":"CPP特点-输出长度与精度控制-指针与常量"},{"content":"","date":null,"permalink":"/cpp/","section":"CPPs","summary":"","title":"CPPs"},{"content":"","date":null,"permalink":"/","section":"House of Eternity","summary":"","title":"House of Eternity"},{"content":"","date":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":null,"permalink":"/tags/cpp/","section":"Tags","summary":"","title":"CPP"},{"content":"","date":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":null,"permalink":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","section":"Categories","summary":"","title":"学习笔记"},{"content":"类的构造函数和析构函数 #构造函数 # 构造函数的名字必须与类名相同，且不能有返回参数 class Complex{ Private: double real; double imag; Public: Complex(double r,double i) {real=r;imag=i;} }; 定义对象时，编译系统会自动调用构造函数~~（初始化）~~ 与普通成员函数一样，可以定义在体内也可以定义在体外 构造函数的主要作用是对对象进行初始化 构造函数一般声明为公有成员，但不能像其他成员一样被显式调用它在定义对象的同时被调用，且只调用一次 在实际应用中有通常要为每一个类定义构造函数 构造函数可以不带参数 构造函数可以重载 用成员初始化列表对数据成员初始化 # 一般表达形式 类名::构造函数名([参数表])[:(成员初始化列表)] {//构造函数体} 成员初始化列表一般形式 数据成员1(初始值1),数据成员2(初始值2),\u0026hellip;..\n析构函数 # 定义 是一种特殊的成员函数，与构造函数功能相反，它用来释放对象，即当删除对象前，回收储存空间并进行一些清理工作 性质 析构函数名称与类名相同，但它名称前面必须要加一个～ 析构函数没有返回值，也没有参数 当对象生命周期结束时，编译系统会自动调用析构函数 析构函数不能重载 对象数组 # 指每一数组元素都是对象的数组 定义形式 类名 数组名 [下标表达式] Complex com[10] 有几个数组元素就要调用几次构造函数 如果构造函数只有一个参数，在定义对象数组时可以直接在等号后面的花括号内提供实参 使用格式 数组名[下标].成员名 当类中有多个参数的构造函数时，则必须使用如下的形式进行对象数组的初始化 Complex com[3]={ //定义对象数组com Complex(1.1,2.2),//为第一个对象数组元素提供实参 Complex(3.3,4,4),//为第二个对象数组元素提供实参 Complex(5.5,6.6)//为第三个对象数组元素提供实参 }; 对象指针 # 在CPP中，可以直接引用对象，也可通过指向该对象的指针引用对象 exe ob; //定义类exe的对象ob exe *p; //定义指向类exe的对象指针p P=\u0026amp;ob;//将对象ob的地址赋给对象指针p 用对象指针访问对象数组 exe ob[2];//定义类exe的对象数组ob[2] exe *p;//定义指向类exe的对象指针p //数组名代表第一个元素的地址 P=ob; //将对象数组ob的地址赋给对象指针p this指针 # 在每个对象的数据成员中都有一个系统隐含的指针this 这个指针this的类型为这个对象所属类的类型 这个指针this的值为包含它的那个对象的首地址 ","date":"18 April 2024","permalink":"/cpp/4/","section":"CPPs","summary":"类的构造函数和析构函数 #构造函数 # 构造函数的名字必须与类名相同，且不能有返回参数 class Complex{ Private: double real; double imag; Public: Complex(double r,double i) {real=r;imag=i;} }; 定义对象时，编译系统会自动调用构造函数~~（初始化）~~ 与普通成员函数一样，可以定义在体内也可以定义在体外 构造函数的主要作用是对对象进行初始化 构造函数一般声明为公有成员，但不能像其他成员一样被显式调用它在定义对象的同时被调用，且只调用一次 在实际应用中有通常要为每一个类定义构造函数 构造函数可以不带参数 构造函数可以重载 用成员初始化列表对数据成员初始化 # 一般表达形式 类名::构造函数名([参数表])[:(成员初始化列表)] {//构造函数体} 成员初始化列表一般形式 数据成员1(初始值1),数据成员2(初始值2),\u0026hellip;.","title":"构造函数－成员列表－析构函数－对象数组和对象指针"},{"content":"","date":null,"permalink":"/tags/%E6%95%B0%E7%94%B5/","section":"Tags","summary":"","title":"数电"},{"content":"逻辑代数公式 # 分配律 \\(A\\cdot(B+C)=A\\cdot B+A\\cdot C\\) \\(A+B \\cdot C=(A+B)\\cdot(A+C)\\) 同一律 \\(A\\cdot A=A\\) \\( A+A=A \\) 德摩根定理 \\(\\overline{A\\cdot B}=\\overline{A}+\\overline{B}\\) \\(\\overline{A+B}=\\overline{A}\\cdot \\overline{B}\\) 还原律 \\(\\overline{\\overline{A}}=A\\) 若干常用公式 \\(A\\cdot B+A\\cdot \\overline{B}=A\\) \\(A+A\\cdot B=A\\) \\(A+\\overline{A}\\cdot B=A+B\\) \\(A\\cdot B+\\overline{A}\\cdot C+B\\cdot C=A\\cdot B+\\overline{A}\\cdot C\\) 逻辑函数的最简表达式 #最简与或式 # 定义: 乘积项的个数最少,每个乘积项中相乘的变量个数也最少的与或表达式,称为最简与或式 最简与非-与非式 # 定义: 非号个数最少,每个非号下面相乘的变量个数也最少的与非-与非式,称为最简与非-与非式 求法: 在最简与或表达式的基础上,两次取反,再用德摩根定理去掉下面的反号,便可得到 最简或与式 # 定义: 括号个数最少,每个括号中相加的变量的个数也最少的或与式,称为最简或与式 求法: 在反函数最简与或式的基础上,取反,再用德摩根定理去掉反号,便可得到函数的最简或与式 最简或非-或非式 # 定义:非号个数最少,每个非号下面相加的变量个数也最少的或非-或非式,称为最简或非-或非表达式 求法:在最简或与表达式的基础上,两次取反,再用德摩根定理去掉下面的反号,所得到的便是函数的最简或非-或非表达式 最简与或非表达式 # 定义:在非号下面相加的乘积项个数最少,每个乘积项中相乘的变量个数也最少的与或非式,称为最简与或非表达式 求法:在最简或非-或非式的基础上,用德摩根定理去掉大反号下面的小反号,便可得到函数的最简与或非表达式 逻辑函数表示方法 #真值表 # 把变量的各种可能取值与相应的函数值,以表格形式一一列举出来. 列写方法: 0、1两种取值,n个变量共有\\(2^n\\)种不同的取值,将他们按二进制数递增规律排列起来,同时在相应位置写上函数的值,便可得到逻辑函数的真值表 卡诺图 # 定义：一个逻辑函数的卡诺图就是将此函数的最小项表达式中的各项最小项相应地填入一个特定的方格图内，此方格图为卡诺图 特点：几何位置相邻的最小项在逻辑上也是相邻的。即相邻的两个最小项只有一个变量不同 注意 对于n个变量的逻辑函数有 2ⁿ个最小项 卡诺图相邻的数为格雷编码，即只有一位二进制数不同（01-\u0026gt;11-\u0026gt;10） 逻辑表达式 # 用与、或、非等运算表示函数中各个变量之间逻辑关系的代数式子,称为逻辑表达式 逻辑图 # 用基本和常用的逻辑符号表示函数表达式中各个变量的运算关系 波形图 # 反映输入和输出变量对应取值随时间按照一定规律变化的图形,就称为波形图,也称时间图 ","date":"1 April 2024","permalink":"/cpp/3/","section":"CPPs","summary":"逻辑代数公式 # 分配律 \\(A\\cdot(B+C)=A\\cdot B+A\\cdot C\\) \\(A+B \\cdot C=(A+B)\\cdot(A+C)\\) 同一律 \\(A\\cdot A=A\\) \\( A+A=A \\) 德摩根定理 \\(\\overline{A\\cdot B}=\\overline{A}+\\overline{B}\\) \\(\\overline{A+B}=\\overline{A}\\cdot \\overline{B}\\) 还原律 \\(\\overline{\\overline{A}}=A\\) 若干常用公式 \\(A\\cdot B+A\\cdot \\overline{B}=A\\) \\(A+A\\cdot B=A\\) \\(A+\\overline{A}\\cdot B=A+B\\) \\(A\\cdot B+\\overline{A}\\cdot C+B\\cdot C=A\\cdot B+\\overline{A}\\cdot C\\) 逻辑函数的最简表达式 #最简与或式 # 定义: 乘积项的个数最少,每个乘积项中相乘的变量个数也最少的与或表达式,称为最简与或式 最简与非-与非式 # 定义: 非号个数最少,每个非号下面相乘的变量个数也最少的与非-与非式,称为最简与非-与非式 求法: 在最简与或表达式的基础上,两次取反,再用德摩根定理去掉下面的反号,便可得到 最简或与式 # 定义: 括号个数最少,每个括号中相加的变量的个数也最少的或与式,称为最简或与式 求法: 在反函数最简与或式的基础上,取反,再用德摩根定理去掉反号,便可得到函数的最简或与式 最简或非-或非式 # 定义:非号个数最少,每个非号下面相加的变量个数也最少的或非-或非式,称为最简或非-或非表达式 求法:在最简或与表达式的基础上,两次取反,再用德摩根定理去掉下面的反号,所得到的便是函数的最简或非-或非表达式 最简与或非表达式 # 定义:在非号下面相加的乘积项个数最少,每个乘积项中相乘的变量个数也最少的与或非式,称为最简与或非表达式 求法:在最简或非-或非式的基础上,用德摩根定理去掉大反号下面的小反号,便可得到函数的最简与或非表达式 逻辑函数表示方法 #真值表 # 把变量的各种可能取值与相应的函数值,以表格形式一一列举出来.","title":"逻辑代数公式及最简表达式"},{"content":"k## 作用域运算符::\n说明 # 如果两个变量同名,一个全局的,一个局部的,那么局部变量在其作用域内具有较高的优先级 联合 #声明 #union data { int i; double d; }x; 访问时 x.i x.d 无名联合 # 是cpp中的特殊联合,它在关键字union后面没有给出联合名,它可使一组数据共用同一内存地址 结构体对齐\n强制类型转换 # OLD int i =10; float x=(float)i; NEW int 1=10; float x=float(i); new与delete运算符 #C语言内存动态分配 #int *p; p=(int*)malloc(sizeof(int)); free(p); CPP语言动态分配 #int *p; p=new int; delete p; 用法 # 用new申请空间的格式 p = new type; 用delete释放所申请的空间格式 delete p; 特殊用法 # 用new分配内存的同时,可以用()指定其初始值,但不能为数组元素指定初值 int *p; p = new int(99); 用new建立多维数组类型的变量 p=new type[size][m][n]...[s]; int (*pi)[3][4]=new int [i*4][3][4]; 用new可为动态数组分配内存空间 p=new float[5]; p=new int[m]; p=new double[m+5*n]; new和delete应该配对使用 #引用(CPP独占) # 引用相当于为某个变量、常量、数组或对象起了一个别名 使用 # 如果引用不是用作函数的参数或返回值,则必须在说明时初始化 int i; int \u0026amp;j; j=i; is ERROR\nint i; int \u0026amp;j=i; is RIGHT\n不是任何类型的数据都可以引用 不允许建立void类型的引用 不允许建立引用的数组 不能建立引用的引用;不能建立指向引用的指针; ","date":"29 March 2024","permalink":"/cpp/2/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/","section":"CPPs","summary":"k## 作用域运算符::","title":"作用域运算符-联合-强转-内存动态分配-引用"},{"content":"逗号语句执行 #printf(\u0026quot;%d\u0026quot;,(int a=3*5,a*4,a+5));\noutput\u0026gt;:20 在这个 printf 语句中，a=3 * 5 , a * 4,a+5 是一个逗号表达式。逗号表达式会依次计算其内部的子表达式，并返回最后一个子表达式的值。但是，逗号表达式的一个重要特性是，它会保证所有的子表达式（从左到右）都会被求值，并且除了最后一个子表达式的结果都会被丢弃\n带有默认(缺省)参数的函数 # 缺省函数必须从左往右定义,并且在一个缺省参数的右边不能有未指定的缺省值的参数. 定义 # 在函数定义or函数声明中指定了初始值的参数称为默认参数 int special(int x=5,float y=5.3); 初始化 # 可定义为任意的初始化表达式,可以包含函数调用以及全局变量等 int fun (int w=sqrt(a),int x=a*a); 说明 # void fun(int w,int x=1 ,int y=1,int z=1) is RIGHT\nvoid fun(int w,int x=1 ,int y, int z=1) is ERROR\n规则 # 如果函数定义在前,函数调用在后,在函数定义处写默认值 如果函数调用在前,函数定义在后,在函数声明处写默认值,函数定义处不要写 函数重载与默认值 #说明 # 缺省函数必须从右往左定义,并且在一个缺省参数的右边不能有未指定的缺省值的参数 void fun(int w,int x ,int y=1 ); void fun(int w,int x ); 该段代码有歧义若参数为 2,3 以上两种方式均合适产生二义性导致报错 ","date":"28 March 2024","permalink":"/cpp/1/%E9%80%97%E5%8F%B7%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C-%E9%BB%98%E8%AE%A4%E5%80%BC%E7%9B%B8%E5%85%B3/","section":"CPPs","summary":"逗号语句执行 #printf(\u0026quot;%d\u0026quot;,(int a=3*5,a*4,a+5));","title":"逗号语句执行-默认值相关-函数重载"},{"content":"本博客由22年部署现迁移至github+hugo #原地址：https://emiya-omega.gitlab.io 警告! 本博客不针对移动端进行页面优化! ","date":"27 March 2024","permalink":"/posts/test/test/","section":"Posts","summary":"本博客由22年部署现迁移至github+hugo #原地址：https://emiya-omega.","title":"About"},{"content":"","date":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":null,"permalink":"/tags/%E4%BB%8B%E7%BB%8D/","section":"Tags","summary":"","title":"介绍"},{"content":"","date":null,"permalink":"/categories/%E6%9D%82%E6%96%87/","section":"Categories","summary":"","title":"杂文"}]