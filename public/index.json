[{"content":"","date":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":null,"permalink":"/tags/ds/","section":"Tags","summary":"","title":"DS"},{"content":"","date":null,"permalink":"/ds/","section":"DSes","summary":"","title":"DSes"},{"content":"","date":null,"permalink":"/","section":"House of Eternity","summary":"","title":"House of Eternity"},{"content":"","date":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":" 前缀函数 #定义 #给定一个长度为 \\(n\\) 的字符串 \\(s\\)，其 前缀函数 被定义为一个长度为 \\(n\\) 的数组 \\(\\pi\\)。 其中 \\(\\pi[i]\\) 的定义是：\n如果子串 \\(s[0\\dots i]\\) 有一对相等的真前缀与真后缀：\\(s[0\\dots k-1]\\) 和 \\(s[i - (k - 1) \\dots i]\\)，那么 \\(\\pi[i]\\) 就是这个相等的真前缀（或者真后缀，因为它们相等）的长度，也就是 \\(\\pi[i]=k\\)； 如果不止有一对相等的，那么 \\(\\pi[i]\\) 就是其中最长的那一对的长度； 如果没有相等的，那么 \\(\\pi[i]=0\\)。 简单来说 \\(\\pi[i]\\) 就是，子串 //(s[0\\dots i]\\) 最长的相等的真前缀与真后缀的长度。\n用数学语言描述如下：\n$$ \\pi[i] = \\max_{k = 0 \\dots i}\\{k: s[0 \\dots k - 1] = s[i - (k - 1) \\dots i]\\} $$特别地，规定 \\(\\pi[0]=0\\)。\n过程 #举例来说，对于字符串 abcabcd，\n\\(\\pi[0]=0\\)，因为 a 没有真前缀和真后缀，根据规定为 0\n\\(\\pi[1]=0\\)，因为 ab 无相等的真前缀和真后缀\n\\(\\pi[2]=0\\)，因为 abc 无相等的真前缀和真后缀\n\\(\\pi[3]=1\\)，因为 abca 只有一对相等的真前缀和真后缀：a，长度为 1\n\\(\\pi[4]=2\\)，因为 abcab 相等的真前缀和真后缀只有 ab，长度为 2\n\\(\\pi[5]=3\\)，因为 abcabc 相等的真前缀和真后缀只有 abc，长度为 3\n\\(\\pi[6]=0\\)，因为 abcabcd 无相等的真前缀和真后缀\n同理可以计算字符串 aabaaab 的前缀函数为 \\([0, 1, 0, 1, 2, 2, 3]\\)。\n计算前缀函数的朴素算法 #过程 #一个直接按照定义计算前缀函数的算法流程：\n在一个循环中以 \\(i = 1\\to n - 1\\) 的顺序计算前缀函数 \\(\\pi[i]\\) 的值（\\(\\pi[0]\\) 被赋值为 \\(0\\)）。\n为了计算当前的前缀函数值 \\(\\pi[i]\\)，我们令变量 \\(j\\) 从最大的真前缀长度 \\(i\\) 开始尝试。\n如果当前长度下真前缀和真后缀相等，则此时长度为 \\(\\pi[i]\\)，否则令 j 自减 1，继续匹配，直到\\(j=0\\)。\n如果 \\(j = 0\\) 并且仍没有任何一次匹配，则置 \\(\\pi[i] = 0\\) 并移至下一个下标 \\(i + 1\\)。\n具体实现如下：\n// 注： // string substr (size_t pos = 0, size_t len = npos) const; vector\u0026lt;int\u0026gt; prefix_function(string s) { int n = (int)s.length(); vector\u0026lt;int\u0026gt; pi(n); for (int i = 1; i \u0026lt; n; i++) for (int j = i; j \u0026gt;= 0; j--) if (s.substr(0, j) == s.substr(i - j + 1, j)) { pi[i] = j; break; } return pi; } def prefix_function(s): n = len(s) pi = [0] * n for i in range(1, n): for j in range(i, -1, -1): if s[0:j] == s[i - j + 1 : i + 1]: pi[i] = j break return pi static int[] prefix_function(String s) { int n = s.length(); int[] pi = new int[n]; for (int i = 1; i \u0026lt; n; i++) { for (int j = i; j \u0026gt;= 0; j--) { if (s.substring(0, j).equals(s.substring(i - j + 1, i + 1))) { pi[i] = j; break; } } } return pi; } 显见该算法的时间复杂度为 $O(n^3)$，具有很大的改进空间。\n计算前缀函数的高效算法 #第一个优化 #第一个重要的观察是 相邻的前缀函数值至多增加 \\(1\\)。\n参照下图所示，只需如此考虑：当取一个尽可能大的 \\(\\pi[i+1]\\) 时，必然要求新增的 \\(s[i+1]\\) 也与之对应的字符匹配，即 \\(s[i+1]=s[\\pi[i]]\\), 此时 \\(\\pi[i+1] = \\pi[i]+1\\)。\n\\( \\underbrace{\\overbrace{s_0 ~ s_1 ~ s_2}^{\\pi[i] = 3} ~ s_3}{\\pi[i+1] = 4} ~ \\dots ~ \\underbrace{\\overbrace{s{i-2} ~ s_{i-1} ~ s_{i}}^{\\pi[i] = 3} ~ s_{i+1}}_{\\pi[i+1] = 4} \\)\n所以当移动到下一个位置时，前缀函数的值要么增加一，要么维持不变，要么减少。\n此时的改进的算法为：\nvector\u0026lt;int\u0026gt; prefix_function(string s) { int n = (int)s.length(); vector\u0026lt;int\u0026gt; pi(n); for (int i = 1; i \u0026lt; n; i++) for (int j = pi[i - 1] + 1; j \u0026gt;= 0; j--) // improved: j=i =\u0026gt; j=pi[i-1]+1 if (s.substr(0, j) == s.substr(i - j + 1, j)) { pi[i] = j; break; } return pi; } def prefix_function(s): n = len(s) pi = [0] * n for i in range(1, n): for j in range(pi[i - 1] + 1, -1, -1): if s[0:j] == s[i - j + 1 : i + 1]: pi[i] = j break return pi static int[] prefix_function(String s) { int n = s.length(); int[] pi = new int[n]; for (int i = 1; i \u0026lt; n; i++) { for (int j = pi[i - 1] + 1; j \u0026gt;= 0; j--) { if (s.substring(0, j).equals(s.substring(i - j + 1, i + 1))) { pi[i] = j; break; } } } return pi; } 在这个初步改进的算法中，在计算每个 \\(\\pi[i]\\) 时，最好的情况是第一次字符串比较就完成了匹配，也就是说基础的字符串比较次数是 n-1 次。\n而由于存在 j = pi[i-1]+1（pi[0]=0）对于最大字符串比较次数的限制，可以看出每次只有在最好情况才会为字符串比较次数的上限积累 1，而每次超过一次的字符串比较消耗的是之后次数的增长空间。\n由此我们可以得出字符串比较次数最多的一种情况：至少 1 次字符串比较次数的消耗和最多 n-2 次比较次数的积累，此时字符串比较次数为 n-1 + n-2 = 2n-3。\n可见经过此次优化，计算前缀函数只需要进行 \\(O(n)\\) 次字符串比较，总复杂度降为了 \\(O(n^2)\\)。\n第二个优化 #在第一个优化中，我们讨论了计算 \\(\\pi[i+1]\\) 时的最好情况：\\(s[i+1]=s[\\pi[i]]$，此时 $\\pi[i+1] = \\pi[i]+1\\)。现在让我们沿着这个思路走得更远一点：讨论当 \\(s[i+1] \\neq s[\\pi[i]]\\) 时如何跳转。\n失配时，我们希望找到对于子串 \\(s[0\\dots i]\\)，仅次于 \\(\\pi[i]\\) 的第二长度 \\(j\\)，使得在位置 \\(i\\) 的前缀性质仍得以保持，也即 \\(s[0 \\dots j - 1] = s[i - j + 1 \\dots i]\\)：\n$$ \\overbrace{\\underbrace{s_0 ~ s_1}_j ~ s_2 ~ s_3}^{\\pi[i]} ~ \\dots ~ \\overbrace{s_{i-3} ~ s_{i-2} ~ \\underbrace{s_{i-1} ~ s_{i}}_j}^{\\pi[i]} ~ s_{i+1} $$如果我们找到了这样的长度 $j$，那么仅需要再次比较 \\(s[i + 1]\\) 和 \\(s[j]\\)。如果它们相等，那么就有 \\(\\pi[i + 1] = j + 1\\)。否则，我们需要找到子串 \\(s[0\\dots i]\\) 仅次于 \\(j\\) 的第二长度 \\(j^{(2)}\\)，使得前缀性质得以保持，如此反复，直到 \\(j = 0\\)。如果 \\(s[i + 1] \\neq s[0]\\)，则 \\(\\pi[i + 1] = 0\\)。\n观察上图可以发现，因为 \\(s[0\\dots \\pi[i]-1] = s[i-\\pi[i]+1\\dots i]\\)，所以对于 \\(s[0\\dots i]\\) 的第二长度 \\(j\\)，有这样的性质：\n$$ s[0 \\dots j - 1] = s[i - j + 1 \\dots i]= s[\\pi[i]-j\\dots \\pi[i]-1] $$也就是说 \\(j\\) 等价于子串 \\(s[\\pi[i]-1]\\) 的前缀函数值，即 \\(j=\\pi[\\pi[i]-1]\\)。同理，次于 \\(j\\) 的第二长度等价于 \\(s[j-1]\\)的前缀函数值，\\(j^{(2)}=\\pi[j-1]\\)\n显然我们可以得到一个关于 \\(j\\) 的状态转移方程：\\(j^{(n)}=\\pi[j^{(n-1)}-1], \\ \\ (j^{(n-1)}\u0026gt;0)\\)\n最终算法 #所以最终我们可以构建一个不需要进行任何字符串比较，并且只进行 \\(O(n)\\)s 次操作的算法。\n而且该算法的实现出人意料的短且直观：\nvector\u0026lt;int\u0026gt; prefix_function(string s) { int n = (int)s.length(); vector\u0026lt;int\u0026gt; pi(n); for (int i = 1; i \u0026lt; n; i++) { int j = pi[i - 1]; while (j \u0026gt; 0 \u0026amp;\u0026amp; s[i] != s[j]) j = pi[j - 1]; if (s[i] == s[j]) j++; pi[i] = j; } return pi; } def prefix_function(s): n = len(s) pi = [0] * n for i in range(1, n): j = pi[i - 1] while j \u0026gt; 0 and s[i] != s[j]: j = pi[j - 1] if s[i] == s[j]: j += 1 pi[i] = j return pi static int[] prefix_function(String s) { int n = s.length(); int[] pi = new int[n]; for (int i = 1; i \u0026lt; n; i++) { int j = pi[i - 1]; while (j \u0026gt; 0 \u0026amp;\u0026amp; s.charAt(i) != s.charAt(j)) { j = pi[j - 1]; } if (s.charAt(i) == s.charAt(j)) { j++; } pi[i] = j; } return pi; } 这是一个 在线 算法，即其当数据到达时处理它——举例来说，你可以一个字符一个字符的读取字符串，立即处理它们以计算出每个字符的前缀函数值。该算法仍然需要存储字符串本身以及先前计算过的前缀函数值，但如果我们已经预先知道该字符串前缀函数的最大可能取值 \\(M\\)，那么我们仅需要存储该字符串的前 \\(M + 1\\) 个字符以及对应的前缀函数值。\n应用 #在字符串中查找子串：Knuth–Morris–Pratt 算法 #该算法由 Knuth、Pratt 和 Morris 在 1977 年共同发布\\[1\\]。\n该任务是前缀函数的一个典型应用。\n过程 #给定一个文本 \\(t\\) 和一个字符串 \\(s\\)，我们尝试找到并展示 \\(s\\) 在 \\(t\\) 中的所有出现（occurrence）。\n为了简便起见，我们用 \\(n\\) 表示字符串 \\(s\\) 的长度，用 \\(m\\) 表示文本 \\(t\\) 的长度。\n我们构造一个字符串 \\(s + # + t\\)，其中 \\(#\\) 为一个既不出现在 \\(s\\) 中也不出现在 \\(t\\) 中的分隔符。接下来计算该字符串的前缀函数。现在考虑该前缀函数除去最开始 \\(n + 1\\) 个值（即属于字符串 \\(s\\) 和分隔符的函数值）后其余函数值的意义。根据定义，\\(\\pi[i]\\) 为右端点在 \\(i\\) 且同时为一个前缀的最长真子串的长度，具体到我们的这种情况下，其值为与 \\(s\\) 的前缀相同且右端点位于 \\(i\\) 的最长子串的长度。由于分隔符的存在，该长度不可能超过 \\(n\\)。而如果等式 \\(\\pi[i] = n\\) 成立，则意味着 \\(s\\) 完整出现在该位置（即其右端点位于位置 \\(i\\)）。注意该位置的下标是对字符串 \\(s + # + t\\) 而言的。\n因此如果在某一位置 $i$ 有 $\\pi[i] = n$ 成立，则字符串 $s$ 在字符串 $t$ 的 $i - (n - 1) - (n + 1) = i - 2n$ 处出现。\n正如在前缀函数的计算中已经提到的那样，如果我们知道前缀函数的值永远不超过一特定值，那么我们不需要存储整个字符串以及整个前缀函数，而只需要二者开头的一部分。在我们这种情况下这意味着只需要存储字符串 $s + \\#$ 以及相应的前缀函数值即可。我们可以一次读入字符串 $t$ 的一个字符并计算当前位置的前缀函数值。\n因此 Knuth–Morris–Pratt 算法（简称 KMP 算法）用 $O(n + m)$ 的时间以及 $O(n)$ 的内存解决了该问题。\nvector\u0026lt;int\u0026gt; find_occurrences(string text, string pattern) { string cur = pattern + \u0026#39;#\u0026#39; + text; int sz1 = text.size(), sz2 = pattern.size(); vector\u0026lt;int\u0026gt; v; vector\u0026lt;int\u0026gt; lps = prefix_function(cur); for (int i = sz2 + 1; i \u0026lt;= sz1 + sz2; i++) { if (lps[i] == sz2) v.push_back(i - 2 * sz2); } return v; } def find_occurrences(t, s): cur = s + \u0026#34;#\u0026#34; + t sz1, sz2 = len(t), len(s) ret = [] lps = prefix_function(cur) for i in range(sz2 + 1, sz1 + sz2 + 1): if lps[i] == sz2: ret.append(i - 2 * sz2) return ret static List\u0026lt;Integer\u0026gt; find_occurrences(String text, String pattern) { String cur = pattern + \u0026#39;#\u0026#39; + text; int sz1 = text.length(), sz2 = pattern.length(); List\u0026lt;Integer\u0026gt; v = new ArrayList\u0026lt;\u0026gt;(); int[] lps = prefix_function(cur); for (int i = sz2 + 1; i \u0026lt;= sz1 + sz2; i++) { if (lps[i] == sz2) { v.add(i - 2 * sz2); } } return v; } 字符串的周期 #对字符串 $s$ 和 $0 \u003c p \\le |s|$，若 $s[i] = s[i+p]$ 对所有 $i \\in [0, |s| - p - 1]$ 成立，则称 $p$ 是 $s$ 的周期。\n对字符串 $s$ 和 $0 \\le r \u003c |s|$，若 $s$ 长度为 $r$ 的前缀和长度为 $r$ 的后缀相等，就称 $s$ 长度为 $r$ 的前缀是 $s$ 的 border。\n由 $s$ 有长度为 $r$ 的 border 可以推导出 $|s|-r$ 是 $s$ 的周期。\n根据前缀函数的定义，可以得到 $s$ 所有的 border 长度，即 $\\pi[n-1],\\pi[\\pi[n-1]-1], \\ldots$。1\n所以根据前缀函数可以在 $O(n)$ 的时间内计算出 $s$ 所有的周期。其中，由于 $\\pi[n-1]$ 是 $s$ 最长 border 的长度，所以 $n - \\pi[n-1]$ 是 $s$ 的最小周期。\n统计每个前缀的出现次数 #在该节我们将同时讨论两个问题。给定一个长度为 $n$ 的字符串 $s$，在问题的第一个变种中我们希望统计每个前缀 $s[0 \\dots i]$ 在同一个字符串的出现次数，在问题的第二个变种中我们希望统计每个前缀 $s[0 \\dots i]$ 在另一个给定字符串 $t$ 中的出现次数。\n首先让我们来解决第一个问题。考虑位置 $i$ 的前缀函数值 $\\pi[i]$。根据定义，其意味着字符串 $s$ 一个长度为 $\\pi[i]$ 的前缀在位置 $i$ 出现并以 $i$ 为右端点，同时不存在一个更长的前缀满足前述定义。与此同时，更短的前缀可能以该位置为右端点。容易看出，我们遇到了在计算前缀函数时已经回答过的问题：给定一个长度为 $j$ 的前缀，同时其也是一个右端点位于 $i$ 的后缀，下一个更小的前缀长度 $k \u003c j$ 是多少？该长度的前缀需同时也是一个右端点为 $i$ 的后缀。因此以位置 $i$ 为右端点，有长度为 $\\pi[i]$ 的前缀，有长度为 $\\pi[\\pi[i] - 1]$ 的前缀，有长度为 $\\pi[\\pi[\\pi[i] - 1] - 1]$ 的前缀，等等，直到长度变为 $0$。故而我们可以通过下述方式计算答案。\n```cpp vector\u0026lt;int\u0026gt; ans(n + 1); for (int i = 0; i \u0026lt; n; i++) ans[pi[i]]++; for (int i = n - 1; i \u0026gt; 0; i--) ans[pi[i - 1]] += ans[i]; for (int i = 0; i \u0026lt;= n; i++) ans[i]++; ``` ```python ans = [0] * (n + 1) for i in range(0, n): ans[pi[i]] += 1 for i in range(n - 1, 0, -1): ans[pi[i - 1]] += ans[i] for i in range(0, n + 1): ans[i] += 1 ``` 解释 #在上述代码中我们首先统计每个前缀函数值在数组 $\\pi$ 中出现了多少次，然后再计算最后答案：如果我们知道长度为 $i$ 的前缀出现了恰好 $\\text{ans}[i]$ 次，那么该值必须被叠加至其最长的既是后缀也是前缀的子串的出现次数中。在最后，为了统计原始的前缀，我们对每个结果加 $1$。\n现在考虑第二个问题。我们应用来自 Knuth–Morris–Pratt 的技巧：构造一个字符串 $s + \\# + t$ 并计算其前缀函数。与第一个问题唯一的不同之处在于，我们只关心与字符串 $t$ 相关的前缀函数值，即 $i \\ge n + 1$ 的 $\\pi[i]$。有了这些值之后，我们可以同样应用在第一个问题中的算法来解决该问题。\n一个字符串中本质不同子串的数目 #给定一个长度为 $n$ 的字符串 $s$，我们希望计算其本质不同子串的数目。\n我们将迭代的解决该问题。换句话说，在知道了当前的本质不同子串的数目的情况下，我们要找出一种在 $s$ 末尾添加一个字符后重新计算该数目的方法。\n令 $k$ 为当前 $s$ 的本质不同子串数量。我们添加一个新的字符 $c$ 至 $s$。显然，会有一些新的子串以字符 $c$ 结尾。我们希望对这些以该字符结尾且我们之前未曾遇到的子串计数。\n构造字符串 $t = s + c$ 并将其反转得到字符串 $t^{\\sim}$。现在我们的任务变为计算有多少 $t^{\\sim}$ 的前缀未在 $t^{\\sim}$ 的其余任何地方出现。如果我们计算了 $t^{\\sim}$ 的前缀函数最大值 $\\pi_{\\max}$，那么最长的出现在 $s$ 中的前缀其长度为 $\\pi_{\\max}$。自然的，所有更短的前缀也出现了。\n因此，当添加了一个新字符后新出现的子串数目为 $|s| + 1 - \\pi_{\\max}$。\n所以对于每个添加的字符，我们可以在 $O(n)$ 的时间内计算新子串的数目，故最终复杂度为 $O(n^2)$。\n值得注意的是，我们也可以重新计算在头部添加一个字符，或者从尾或者头移除一个字符时的本质不同子串数目。\n字符串压缩 #给定一个长度为 $n$ 的字符串 $s$，我们希望找到其最短的「压缩」表示，也即我们希望寻找一个最短的字符串 $t$，使得 $s$ 可以被 $t$ 的一份或多份拷贝的拼接表示。\n显然，我们只需要找到 $t$ 的长度即可。知道了该长度，该问题的答案即为长度为该值的 $s$ 的前缀。\n让我们计算 $s$ 的前缀函数。通过使用该函数的最后一个值 $\\pi[n - 1]$，我们定义值 $k = n - \\pi[n - 1]$。我们将证明，如果 $k$ 整除 $n$，那么 $k$ 就是答案，否则不存在一个有效的压缩，故答案为 $n$。\n假定 $n$ 可被 $k$ 整除。那么字符串可被划分为长度为 $k$ 的若干块。根据前缀函数的定义，该字符串长度为 $n - k$ 的前缀等于其后缀。但是这意味着最后一个块同倒数第二个块相等，并且倒数第二个块同倒数第三个块相等，等等。作为其结果，所有块都是相等的，因此我们可以将字符串 $s$ 压缩至长度 $k$。\n诚然，我们仍需证明该值为最优解。实际上，如果有一个比 $k$ 更小的压缩表示，那么前缀函数的最后一个值 $\\pi[n - 1]$ 必定比 $n - k$ 要大。因此 $k$ 就是答案。 现在假设 $n$ 不可以被 $k$ 整除，我们将通过反证法证明这意味着答案为 $n$[^1]。假设其最小压缩表示 $r$ 的长度为 $p$（$p$ 整除 $n$），字符串 $s$ 被划分为 $n / p \\ge 2$ 块。那么前缀函数的最后一个值 $\\pi[n - 1]$ 必定大于 $n - p$（如果等于则 $n$ 可被 $k$ 整除），也即其所表示的后缀将部分的覆盖第一个块。现在考虑字符串的第二个块。该块有两种解释：第一种为 $r_0 r_1 \\dots r_{p - 1}$，另一种为 $r_{p - k} r_{p - k + 1} \\dots r_{p - 1} r_0 r_1 \\dots r_{p - k - 1}$。由于两种解释对应同一个字符串，因此可得到 $p$ 个方程组成的方程组，该方程组可简写为 $r_{(i + k) \\bmod p} = r_{i \\bmod p}$，其中 $\\cdot \\bmod p$ 表示模 $p$ 意义下的最小非负剩余。 $$ \\begin{gathered} \\overbrace{r_0 ~ r_1 ~ r_2 ~ r_3 ~ r_4 ~ r_5}^p ~ \\overbrace{r_0 ~ r_1 ~ r_2 ~ r_3 ~ r_4 r_5}^p \\\\ r_0 ~ r_1 ~ r_2 ~ r_3 ~ \\underbrace{\\overbrace{r_0 ~ r_1 ~ r_2 ~ r_3 ~ r_4 ~ r_5}^p ~ r_0 ~ r_1}_{\\pi[11] = 8} \\end{gathered} $$ 根据扩展欧几里得算法我们可以得到一组 $x$ 和 $y$ 使得 $xk + yp = \\gcd(k, p)$。通过与等式 $pk - kp = 0$ 适当叠加我们可以得到一组 $x' \u0026gt; 0$ 和 $y' \u0026lt; 0$ 使得 $x'k + y'p = \\gcd(k, p)$。这意味着通过不断应用前述方程组中的方程我们可以得到新的方程组 $r_{(i + \\gcd(k, p)) \\bmod p} = r_{i \\bmod p}$。 由于 $\\gcd(k, p)$ 整除 $p$，这意味着 $\\gcd(k, p)$ 是 $r$ 的一个周期。又因为 $\\pi[n - 1] \u0026gt; n - p$，故有 $n - \\pi[n - 1] = k \u0026lt; p$，所以 $\\gcd(k, p)$ 是一个比 $p$ 更小的 $r$ 的周期。因此字符串 $s$ 有一个长度为 $\\gcd(k, p) \u0026lt; p$ 的压缩表示，同 $p$ 的最小性矛盾。 综上所述，不存在一个长度小于 $k$ 的压缩表示，因此答案为 $k$。 根据前缀函数构建一个自动机 #让我们重新回到通过一个分隔符将两个字符串拼接的新字符串。对于字符串 $s$ 和 $t$ 我们计算 $s + \\# + t$ 的前缀函数。显然，因为 $\\#$ 是一个分隔符，前缀函数值永远不会超过 $|s|$。因此我们只需要存储字符串 $s + \\#$ 和其对应的前缀函数值，之后就可以动态计算对于之后所有字符的前缀函数值：\n$$ \\underbrace{s_0 ~ s_1 ~ \\dots ~ s_{n-1} ~ \\#}_{\\text{need to store}} ~ \\underbrace{t_0 ~ t_1 ~ \\dots ~ t_{m-1}}_{\\text{do not need to store}} $$实际上在这种情况下，知道 $t$ 的下一个字符 $c$ 以及之前位置的前缀函数值便足以计算下一个位置的前缀函数值，而不需要用到任何其它 $t$ 的字符和对应的前缀函数值。\n换句话说，我们可以构造一个 自动机（一个有限状态机）：其状态为当前的前缀函数值，而从一个状态到另一个状态的转移则由下一个字符确定。\n因此，即使没有字符串 $t$，我们同样可以应用构造转移表的算法构造一个转移表 $( \\text { old } \\pi , c ) \\rightarrow \\text { new } _ { - } \\pi$：\n```cpp void compute_automaton(string s, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; aut) { s += '#'; int n = s.size(); vector\u0026lt;int\u0026gt; pi = prefix_function(s); aut.assign(n, vector\u0026lt;int\u0026gt;(26)); for (int i = 0; i \u0026lt; n; i++) { for (int c = 0; c \u0026lt; 26; c++) { int j = i; while (j \u0026gt; 0 \u0026amp;\u0026amp; 'a' + c != s[j]) j = pi[j - 1]; if ('a' + c == s[j]) j++; aut[i][c] = j; } } } ``` 然而在这种形式下，对于小写字母表，算法的时间复杂度为 $O(|\\Sigma|n^2)$。注意到我们可以应用动态规划来利用表中已计算过的部分。只要我们从值 $j$ 变化到 $\\pi[j - 1]$，那么我们实际上在说转移 $(j, c)$ 所到达的状态同转移 $(\\pi[j - 1], c)$ 一样，但该答案我们之前已经精确计算过了。\n```cpp void compute_automaton(string s, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; aut) { s += '#'; int n = s.size(); vector\u0026lt;int\u0026gt; pi = prefix_function(s); aut.assign(n, vector\u0026lt;int\u0026gt;(26)); for (int i = 0; i \u0026lt; n; i++) { for (int c = 0; c \u0026lt; 26; c++) { if (i \u0026gt; 0 \u0026amp;\u0026amp; 'a' + c != s[i]) aut[i][c] = aut[pi[i - 1]][c]; else aut[i][c] = i + ('a' + c == s[i]); } } } ``` 最终我们可在 $O(|\\Sigma|n)$ 的时间复杂度内构造该自动机。\n该自动机在什么时候有用呢？首先，记得大部分时候我们为了一个目的使用字符串 $s + \\# + t$ 的前缀函数：寻找字符串 $s$ 在字符串 $t$ 中的所有出现。\n因此使用该自动机的最直接的好处是 加速计算字符串 $s + \\# + t$ 的前缀函数。\n通过构建 $s + \\#$ 的自动机，我们不再需要存储字符串 $s$ 以及其对应的前缀函数值。所有转移已经在表中计算过了。\n但除此以外，还有第二个不那么直接的应用。我们可以在字符串 $t$ 是 某些通过一些规则构造的巨型字符串 时，使用该自动机加速计算。Gray 字符串，或者一个由一些短的输入串的递归组合所构造的字符串都是这种例子。\n出于完整性考虑，我们来解决这样一个问题：给定一个数 $k \\le 10^5$，以及一个长度 $\\le 10^5$ 的字符串 $s$，我们需要计算 $s$ 在第 $k$ 个 Gray 字符串中的出现次数。回想起 Gray 字符串以下述方式定义：\n$$ \\begin{aligned} g_1 \u0026= \\mathtt{a}\\\\ g_2 \u0026= \\mathtt{aba}\\\\ g_3 \u0026= \\mathtt{abacaba}\\\\ g_4 \u0026= \\mathtt{abacabadabacaba} \\end{aligned} $$由于其天文数字般的长度，在这种情况下即使构造字符串 $t$ 都是不可能的：第 $k$ 个 Gray 字符串有 $2^k - 1$ 个字符。然而我们可以在仅仅知道开头若干前缀函数值的情况下，有效计算该字符串末尾的前缀函数值。\n除了自动机之外，我们同时需要计算值 $G[i][j]$：在从状态 $j$ 开始处理 $g_i$ 后的自动机的状态，以及值 $K[i][j]$：当从状态 $j$ 开始处理 $g_i$ 后，$s$ 在 $g_i$ 中的出现次数。实际上 $K[i][j]$ 为在执行操作时前缀函数取值为 $|s|$ 的次数。易得问题的答案为 $K[k][0]$。\n我们该如何计算这些值呢？首先根据定义，初始条件为 $G[0][j] = j$ 以及 $K[0][j] = 0$。之后所有值可以通过先前的值以及使用自动机计算得到。为了对某个 $i$ 计算相应值，回想起字符串 $g_i$ 由 $g_{i - 1}$，字母表中第 $i$ 个字符，以及 $g_{i - 1}$ 三者拼接而成。因此自动机会途径下列状态：\n$$ \\begin{gathered} \\text{mid} = \\text{aut}[G[i - 1][j]][i] \\\\ G[i][j] = G[i - 1][\\text{mid}] \\end{gathered} $$$K[i][j]$ 的值同样可被简单计算。\n$$ K[i][j] = K[i - 1][j] + [\\text{mid} == |s|] + K[i - 1][\\text{mid}] $$其中 $[\\cdot]$ 当其中表达式取值为真时值为 $1$，否则为 $0$。综上，我们已经可以解决关于 Gray 字符串的问题，以及一大类与之类似的问题。举例来说，应用同样的方法可以解决下列问题：给定一个字符串 $s$ 以及一些模式 $t_i$，其中每个模式以下列方式给出：该模式由普通字符组成，当中可能以 $t_{k}^{\\text{cnt}}$ 的形式递归插入先前的字符串，也即在该位置我们必须插入字符串 $t_k$ $\\text{cnt}$ 次。以下是这些模式的一个例子：\n$$ \\begin{aligned} t_1 \u0026= \\mathtt{abdeca} \\\\ t_2 \u0026= \\mathtt{abc} + t_1^{30} + \\mathtt{abd} \\\\ t_3 \u0026= t_2^{50} + t_1^{100} \\\\ t_4 \u0026= t_2^{10} + t_3^{100} \\end{aligned} $$递归代入会使字符串长度爆炸式增长，他们的长度甚至可以达到 $100^{100}$ 的数量级。而我们必须找到字符串 $s$ 在每个字符串中的出现次数。\n该问题同样可通过构造前缀函数的自动机解决。同之前一样，我们利用先前计算过的结果对每个模式计算其转移然后相应统计答案即可。\n练习题目 # UVa 455 \u0026ldquo;Periodic Strings\u0026rdquo; UVa 11022 \u0026ldquo;String Factoring\u0026rdquo; UVa 11452 \u0026ldquo;Dancing the Cheeky-Cheeky\u0026rdquo; UVa 12604 - Caesar Cipher UVa 12467 - Secret Word UVa 11019 - Matrix Matcher SPOJ - Pattern Find Codeforces - Anthem of Berland Codeforces - MUH and Cube Walls 参考资料与注释 #本页面主要译自博文 Префикс-функция. Алгоритм Кнута-Морриса-Пратта 与其英文翻译版 Prefix function. Knuth–Morris–Pratt algorithm。其中俄文版版权协议为 Public Domain + Leave a Link；英文版版权协议为 CC-BY-SA 4.0。\n金策 - 字符串算法选讲\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"21 October 2024","permalink":"/ds/str/","section":"DSes","summary":"","title":"前缀函数与Kmp算法（copy from oi wiki）"},{"content":"","date":null,"permalink":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","section":"Categories","summary":"","title":"学习笔记"},{"content":"线性表的基本概念 #线性表的定义 # 线性表：具有相同特性的数据元素的有限序列 线性表中的数据元素称为元素 线性表中的数据元素个数称为线性表的长度，用n表示，n大于等于0，当n=0时，称为空表 A=(a1,a2,a3,...,an) 线性表中的数据元素ai(1\u0026lt;=i\u0026lt;=n)称为线性表中的第i个元素，ai的序号i称为元素ai在线性表中的位置 线性表中的第一个元素a1没有前驱，最后一个元素an没有后继，其余元素ai(2\u0026lt;=i\u0026lt;=n-1)既有前驱ai-1，也有后继ai+1 线性表中的数据元素之间是一对一的关系 线性表的抽象数据类型 #ADT List{ 数据对象：D={ai|ai∈ElemSet,i=1,2,...,n,n\u0026gt;=0} 数据关系：R1={\u0026lt;ai-1,ai\u0026gt;|ai-1,ai∈D,i=2,3,...,n} 基本操作： InitList(\u0026amp;L); DestroyList(\u0026amp;L); ClearList(\u0026amp;L); ListEmpty(L); ListLength(L); GetElem(L,i,\u0026amp;e); LocateElem(L,e); PriorElem(L,e,\u0026amp;pre_e); NextElem(L,e,\u0026amp;next_e); }ADT List 线性表的顺序表示和实现 # 线性表的顺序表示又称为顺序存储结构或顺序映像 用一组地址连续的存储单元依次存储线性表中的数据元素，从而使得线性表中在逻辑结构上相邻的数据元素在物理存储位置上也相邻 顺序存储的线性表称为顺序表 顺序表的结构体定义 #define MaxSize 50 typedef struct{ ElemType data[MaxSize]; int length; }SqList; 顺序表的基本操作 //初始化线性表 void InitList(SqList \u0026amp;L){ for(int i=0;i\u0026lt;MaxSize;i++){ L.data[i]=0; } L.length=0; } //插入操作 bool ListInsert(SqList \u0026amp;L,int i,ElemType e){ if(i\u0026lt;1||i\u0026gt;L.length+1){ return false; } if(L.length\u0026gt;=MaxSize){ } for(int j=L.length;j\u0026gt;=i;j--){ L.data[j]=L.data[j-1]; } L.data[i-1]=e; L.length++; return true; } //删除操作 bool ListDelete(SqList \u0026amp;L,int i,ElemType \u0026amp;e){ if(i\u0026lt;1||i\u0026gt;L.length){ return false; } e=L.data[i-1]; for(int j=i;j\u0026lt;L.length;j++){ L.data[j-1]=L.data[j]; } L.length--; return true; } //按位查找操作 ElemType GetElem(SqList L,int i){ return L.data[i-1]; } //按值查找操作 int LocateElem(SqList L,ElemType e){ for(int i=0;i\u0026lt;L.length;i++){ if(L.data[i]==e){ return i+1; } } return 0; } 线性表的链式表示和实现 # 线性表的链式表示又称为链式存储结构\n用一组任意的存储单元存储线性表中的数据元素，这组存储单元可以是连续的，也可以是不连续的\n链式存储的线性表称为链表\n链表中的数据元素称为结点，每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储数据元素直接后继位置的指针域\n结点结构体定义\ntypedef struct LNode{ ElemType data; struct LNode *next; }LNode,*LinkList; 链表的基本操作 //初始化链表 void InitList(LinkList \u0026amp;L){ L=(LinkList)malloc(sizeof(LNode)); L-\u0026gt;next=NULL; } //按位查找操作 LNode *GetElem(LinkList L,int i){ int j=1; LNode *p=L-\u0026gt;next; if(i==0){ return L; } if(i\u0026lt;1){ return NULL; } while(p!=NULL\u0026amp;\u0026amp;j\u0026lt;i){ p=p-\u0026gt;next; j++; } return p; } //按值查找操作 LNode *LocateElem(LinkList L,ElemType e){ LNode *p=L-\u0026gt;next; while(p!=NULL\u0026amp;\u0026amp;p-\u0026gt;data!=e){ p=p-\u0026gt;next; } return p; } //插入操作 bool ListInsert(LinkList \u0026amp;L,int i,ElemType e){ LNode *p=GetElem(L,i-1);//找到第i-1个结点 if(p==NULL){ return false; } LNode *s=(LNode *)malloc(sizeof(LNode)); s-\u0026gt;data=e; s-\u0026gt;next=p-\u0026gt;next; p-\u0026gt;next=s; return true; } //删除操作 bool ListDelete(LinkList \u0026amp;L,int i,ElemType \u0026amp;e){ LNode *p=GetElem(L,i-1); if(p==NULL){ return false; } LNode *q=p-\u0026gt;next; e=q-\u0026gt;data; p-\u0026gt;next=q-\u0026gt;next; free(q); return true; } 建立单链表 # 头插法 void CreateList_H(LinkList \u0026amp;L,int n){ L=(LinkList)malloc(sizeof(LNode)); L-\u0026gt;next=NULL; for(int i=0;i\u0026lt;n;i++){ LNode *p=(LNode *)malloc(sizeof(LNode)); scanf(\u0026#34;%d\u0026#34;,\u0026amp;p-\u0026gt;data); p-\u0026gt;next=L-\u0026gt;next; L-\u0026gt;next=p; } } 尾插法 void CreateList_L(LinkList \u0026amp;L,int n){ L=(LinkList)malloc(sizeof(LNode)); L-\u0026gt;next=NULL; LNode *r=L; for(int i=0;i\u0026lt;n;i++){ LNode *p=(LNode *)malloc(sizeof(LNode)); scanf(\u0026#34;%d\u0026#34;,\u0026amp;p-\u0026gt;data); r-\u0026gt;next=p; r=p; } r-\u0026gt;next=NULL; } 双向链表 # 双向链表的结构体定义 typedef struct DNode{ ElemType data; struct DNode *prior,*next; }DNode,*DLinkList; 双向链表的基本操作 //初始化双向链表 void InitDList(DLinkList \u0026amp;L){ L=(DLinkList)malloc(sizeof(DNode)); L-\u0026gt;prior=NULL; L-\u0026gt;next=NULL; } //按位查找操作 DNode *GetElem(DLinkList L,int i){ int j=1; DNode *p=L-\u0026gt;next; if(i==0){ return L; } if(i\u0026lt;1){ return NULL; } while(p!=NULL\u0026amp;\u0026amp;j\u0026lt;i){ p=p-\u0026gt;next; j++; } return p; } //按值查找操作 DNode *LocateElem(DLinkList L,ElemType e){ DNode *p=L-\u0026gt;next; while(p!=NULL\u0026amp;\u0026amp;p-\u0026gt;data!=e){ p=p-\u0026gt;next; } return p; } //插入操作 bool ListInsert(DLinkList \u0026amp;L,int i,ElemType e){ DNode *p=GetElem(L,i-1);//找到第i-1个结点 if(p==NULL){ return false; } DNode *s=(DNode *)malloc(sizeof(DNode)); s-\u0026gt;data=e; s-\u0026gt;next=p-\u0026gt;next; s-\u0026gt;prior=p; if(p-\u0026gt;next!=NULL){ p-\u0026gt;next-\u0026gt;prior=s; } p-\u0026gt;next=s; return true; } //删除操作 bool ListDelete(DLinkList \u0026amp;L,int i,ElemType \u0026amp;e){ DNode *p=GetElem(L,i-1); if(p==NULL){ return false; } DNode *q=p-\u0026gt;next; e=q-\u0026gt;data; p-\u0026gt;next=q-\u0026gt;next; if(q-\u0026gt;next!=NULL){ q-\u0026gt;next-\u0026gt;prior=p; } free(q); return true; } 线性表的顺序表示和链式表示的比较 # 顺序表 优点：可以随机存取，存储密度高 缺点：大片连续空间分配不方便，改变容量不方便 链表 优点：离散的小空间分配方便，改变容量方便 缺点：不可随机存取，存储密度低 线性表的应用 #线性表的合并 # 假设线性表La和Lb分别表示两个集合A和B，现要求一个新的集合A∪B 合并操作 void unionL(LList \u0026amp;La,LList Lb){ int La_len=Llength(La); int Lb_len=Llength(Lb); for(int i=1;i\u0026lt;=Lb_len;i++){ ElemType e; GetElem(Lb,i,e); if(!LocateElem(La,e)){ ListInsert(La,++La_len,e); } } } 静态链表 # 静态链表的结构体定义 #define MaxSize 50 typedef struct{ ElemType data; int next; }SLinkList[MaxSize]; 静态链表的基本操作 //初始化静态链表 void InitList(SLinkList \u0026amp;L){ for(int i=0;i\u0026lt;MaxSize-1;i++){ L[i].next=i+1; } L[MaxSize-1].next=0; } //按位查找操作 int GetElem(SLinkList L,int i){ if(i\u0026lt;1||i\u0026gt;MaxSize){ return 0; } return L[i].next; } //按值查找操作 int LocateElem(SLinkList L,ElemType e){ int i=1; while(i!=0\u0026amp;\u0026amp;L[i].data!=e){ i=L[i].next; } return i; } //插入操作 bool ListInsert(SLinkList \u0026amp;L,int i,ElemType e){ int j=GetElem(L,0); int k=0; for(int l=1;l\u0026lt;i;l++){ k=j; j=L[j].next; } int q=GetElem(L,0); L[0].next=j; L[j].next=q; L[k].next=i; L[i].data=e; L[i].next=q; return true; } //删除操作 bool ListDelete(SLinkList \u0026amp;L,int i,ElemType \u0026amp;e){ int j=GetElem(L,0); int k=0; for(int l=1;l\u0026lt;i;l++){ k=j; j=L[j].next; } int q=L[j].next; e=L[j].data; L[j].next=L[q].next;//将q结点从链表中断开 L[q].next=GetElem(L,0);//回收结点q L[0].next=j; return true; } 静态链表的使用跟顺序表一样，都需要预先分配较大的空间 在进行插入删除操作时，只需要改变指针的指向，不需要移动元素，所以时间复杂度为O(1) 静态链表也可以用于解决哈希冲突问题 循环链表 # 循环链表的结构体定义 typedef struct LNode{ ElemType data; struct LNode *next; }LNode,*LinkList; 循环链表的基本操作 //初始化循环链表 void InitList(LinkList \u0026amp;L){ L=(LinkList)malloc(sizeof(LNode)); L-\u0026gt;next=L; } //按位查找操作 LNode *GetElem(LinkList L,int i){ int j=1; LNode *p=L-\u0026gt;next; if(i==0){ return L; } if(i\u0026lt;1){ return NULL; } while(p!=L\u0026amp;\u0026amp;j\u0026lt;i){ p=p-\u0026gt;next; j++; } return p; } //按值查找操作 LNode *LocateElem(LinkList L,ElemType e){ LNode *p=L-\u0026gt;next; while(p!=L\u0026amp;\u0026amp;p-\u0026gt;data!=e){ } } //插入操作 bool ListInsert(LinkList \u0026amp;L,int i,ElemType e){ LNode *p=GetElem(L,i-1); if(p == NULL){ return false; } LNode *s=(LNode *)malloc(sizeof(LNode)); s-\u0026gt;data=e; s-\u0026gt;next=p-\u0026gt;next; p-\u0026gt;next=s; return true; } //删除操作 bool ListDelete(LinkList \u0026amp;L,int i,ElemType \u0026amp;e){ LNode *p=GetElem(L,i-1); if(p==NULL){ return false; } LNode *q=p-\u0026gt;next; e=q-\u0026gt;data; p-\u0026gt;next=q-\u0026gt;next; free(q); return true; } 特点 表中最后一个结点的指针指向头结点而不再是NULL，整个链表形成一个环 从表中任一结点出发均可找到链表中的其他结点 循环链表可以避免单链表判空操作 循环链表的最后一个结点的next指针指向头结点 循环链表可以用来解决约瑟夫环问题 有序表 #有序表定义 # 有序表是一种线性表，其元素是按关键字有序排列的 所有元素以递增or递减方式有序排列的线性表称为有序表 有序表和线性表的逻辑结构相同，区别是个别运算不同 以顺序结构进行存储时，其中只有ListInsert()基本运算有所差异，其余基本相同。 有序顺序表的ListInsert()运算 void ListInsert(SqList \u0026amp;L,int i,ElemType e){ int j; for(j=L.length;j\u0026gt;=i;j--){ L.data[j]=L.data[j-1]; } L.data[i-1]=e; L.length++; } 有序表的查找 # 有序表的查找 二分查找 插值查找 斐波那契查找 二分查找 假设有序表为L，要查找的元素为e，L的长度为n，则查找过程如下： 取L的中间元素L[mid]，如果L[mid]==e，则查找成功，返回mid 如果L[mid]\u0026gt;e，则在L的左半部分继续查找 如果L[mid]\u0026lt;e，则在L的右半部分继续查找 TBD #","date":"14 September 2024","permalink":"/ds/list/","section":"DSes","summary":"","title":"线性表"},{"content":"","date":null,"permalink":"/tags/cpp/","section":"Tags","summary":"","title":"CPP"},{"content":"","date":null,"permalink":"/cpp/","section":"CPPs","summary":"","title":"CPPs"},{"content":"静态成员 #静态数据成员 # 在一个类中,若将一个数据成员说明为static，这种成员称为静态数据成员。 与一般的数据成员不同，无论建立多少个类的对象，都只有一个静态数据的拷贝。从而实现了同一个类的不同对象之间的数据共享。 定义静态数据成员的格式如下: static 数据类型 数据成员名;\n说明 # 静态数据成员的定义要加上关键字static ； 静态数据成员的初始化应在类声明之后， 定义对象之前，在类外单独进行。初始化格式为: 数据类型 类名::静态数据成员名 = 初始值\n静态数据成员属于类，而不像普通数据成员那样属于某一对象。因此可以使用以下方式访问静态数据成员: 类名::静态数据成员名 如上例中的: Student::count和Student::sum\n静态数据成员与静态变量一样, 在编译时创建并初始化。 它在该类的任何对象被建立之前就存在。因此, 公有的静态数据成员可以在对象定义之前被访问。对象定义后，也可以通过对象访问公有的静态数据成员，访问格式为: 对象名.静态数据成员名 对象指针-\u0026gt;静态数据成员名\n私有静态数据成员不能被类外部函数访问, 也不能用对象进行访问。 C++支持静态数据成员的一个主要原因是可以不必使用全局变量。依赖于全局变量的类几乎都是违反面向对象程序设计的封装原理。 静态成员函数 # 静态成员函数属于整个类, 是该类所有成员共享的成员函数。定义静态成员函数的格式如下: static 返回类型 静态成员函数名（参数表）;\n与静态数据成员类似,调用公有静态成员函数的一般格式有如下几种: 类名::静态成员函数名(实参表) 对象. 静态成员函数名(实参表) 对象指针-\u0026gt;静态成员函数名(实参表)\n说明 # 一般情况下，静态成员函数主要用来访问全局变量or同一类中的静态数据成员 私有静态成员函数不能被类外部函数和对象访问 静态成员函数可在建立任何对象之前处理静态数据成员，普通成员函数则不能 编译系统将静态成员函数限定为内部连接，也就是与现行文件相连接的其它文件中的同名函数不会与该函数冲突（因编译器而异） 在一般的成员函数中都隐含一个this指针, 用来指向对象本身, 而静态成员函数则没有this指针 静态成员函数一般不访问类中的非静态成员。若确实需要，静态成员函数只能通过对象名(或指向对象的指针)访问非静态成员 cout \u0026lt;\u0026lt; “一只小猫的重量是：” \u0026lt;\u0026lt; weight \u0026lt;\u0026lt; “千克\\n”; //不合法，weight是非静态数据成员 cout \u0026lt;\u0026lt; “小猫的总重量是” \u0026lt;\u0026lt; total_weight \u0026lt;\u0026lt; “千克” \u0026lt;\u0026lt; endl; //合法，total_weight是静态数据成员 若需要访问非静态数据成员，则只能通过对象名。 如：把display函数定义为静态成员函数时，可将对象的引用作为函数参数，将它定义为： static void display (Small_cat \u0026amp;w) cout \u0026laquo; “这只小猫的重量是：” \u0026laquo; w.weight \u0026laquo; “千克\\n”;\n友元 #友元函数 # 将非成员函数声明为友元函数 友元函数不是当前类的成员函数, 而是独立于当前类的外部函数, 但它可以访问该类的所有对象的成员, 包括私有成员、保护成员和公有成员。\n说明 # 友元函数不是成员函数, 在类外部定义友元函数时不必在函数名前加上“类名::”。\n友元函数不是类的成员，它需通过作为入口参数传递进来的对象名去访问引用该对象的数据成员。\ncout \u0026lt;\u0026lt; “女孩的姓名是：” \u0026lt;\u0026lt; x.name; //合法 cout \u0026lt;\u0026lt; “女孩的姓名是：” \u0026lt;\u0026lt; name; //不合法 当一个函数需要访问多个类时，友元函数就显得非常重要。 使用友元函数虽然提高了效率， 但与面向对象的程序设计思想相背，应当谨慎使用。 将成员函数声明为友元函数 # 一个类的成员函数也可以作为另一个类的友元，这种成员函数不仅可以访问自己所在类对象中的所有成员, 还可以访问friend声明语句所在类对象中的所有成员。这样能使两个类相互合作、协调工作,完成某一任务。 友元类 # 一个类作为另一个类的友元 格式 friend　类名；\nclass Y{ ..... }; class X{ ..... friend Y; ..... }; 当类Y被说明为类X的友元时，类Y的所有成员函数都成为类X的友元函数。这就意味着：作为友元类Y中的所有成员函数都可以访问类X中的所有成员（包括私有成员）。 友元关系是单向的，不具备交换性 友元关系不具有传递性 类的组合 # 如有以下的组合类: class X{ 类名1 对象成员名1; 类名2 对象成员名2; … 类名n 对象成员名n; }; 则类X的构造函数的定义形式为;\nX::X(对象成员所需的形参，本类成员形参): 对象成员名1(形参表1),…,对象成员名n(形参表n) { // …构造函数体 } 如有以下的组合类 Student::Student(string name1, string stu_no1, float s1, float s2, float s3): score1(s1, s2, s3)\n构造函数调用顺序 先调用内嵌对象的构造函数（按内嵌时的声明顺序，先声明者先构造）。然后调用本类的构造函数。（析构函数的调用顺序相反） 对上面的代码段而言：先调用对象成员score1的构造函数，再执行类Student的构造函数 ","date":"9 May 2024","permalink":"/cpp/6/","section":"CPPs","summary":"","title":"静态成员-友元函数-类的组合"},{"content":"string类 # string类的字符串对象的使用方法与其他对象一样，但必须先定义才可使用 定义格式 string str1,str2; string str3(\u0026#34;china\u0026#34;); 等价于 string str3=\u0026#34;china\u0026#34;; 向函数传递对象 #使用对象作为函数参数 # 向函数传递对象时,是通过\u0026quot;传值调用\u0026quot;传递给函数 因此,函数中对对象任何修改均不影响调用该函数对象的本身 #include \u0026lt;iostream\u0026gt; class Tr{ public: Tr(int n){ i=n; } void set(int n){ i=n; } int get(){ return i; } private: int i; }; void sqr(Tr ob){ ob.set(ob.get()*ob.get()); cout \u0026lt;\u0026lt;\u0026#34;在函数sqr内,形参对象ob的数据成员i的值为\u0026#34;\u0026lt;\u0026lt;ob.get()\u0026lt;\u0026lt;endl; } int main(){ Tr obj(10); cout\u0026lt;\u0026lt;\u0026#34;调用函数sqr前,实参i值为:\u0026#34;\u0026lt;\u0026lt;obj.get()\u0026lt;\u0026lt;endl; sqr(obj); cout\u0026lt;\u0026lt;\u0026#34;调用函数sqr后,实参i值为:\u0026#34;\u0026lt;\u0026lt;obj.get()\u0026lt;\u0026lt;endl; return 0; } output: 调用函数sqr前,实参i值为:10 在函数sqr内,形参对象ob的数据成员i的值为100 调用函数sqr后,实参i的值为:10\n使用对象指针作为函数参数 # 使用对象指针作为函数参数可以实现\u0026quot;传址调用\u0026quot;,即可在被调用函数中改变调用函数的参数对象的值 #include \u0026lt;iostream\u0026gt; class Tr{ public: Tr(int n){ i=n; } void set(int n){ i=n; } int get(){ return i; } private: int i; }; void sqr(Tr *ob){ ob-\u0026gt;set(ob-\u0026gt;get()*ob-\u0026gt;get()); cout \u0026lt;\u0026lt;\u0026#34;在函数sqr内,形参对象ob的数据成员i的值为\u0026#34;\u0026lt;\u0026lt;ob-\u0026gt;get()\u0026lt;\u0026lt;endl; } int main(){ Tr obj(10); cout\u0026lt;\u0026lt;\u0026#34;调用函数sqr前,实参i值为:\u0026#34;\u0026lt;\u0026lt;obj.get()\u0026lt;\u0026lt;endl; sqr(obj); cout\u0026lt;\u0026lt;\u0026#34;调用函数sqr后,实参i值为:\u0026#34;\u0026lt;\u0026lt;obj.get()\u0026lt;\u0026lt;endl; return 0; } output: 调用函数sqr前,实参i值为:10 在函数sqr内,形参对象ob的数据成员i的值为100 调用函数sqr后,实参i的值为:100\n使用对象引用作为函数参数 # 使用对象引用作为函数参数实现的也是\u0026quot;传址调用\u0026quot;,但比对象指针更简单,更直接,建议使用引用 #include \u0026lt;iostream\u0026gt; class Tr{ public: Tr(int n){ i=n; } void set(int n){ i=n; } int get(){ return i; } private: int i; }; void sqr(Tr \u0026amp;ob){ ob.set(ob.get()*ob.get()); cout \u0026lt;\u0026lt;\u0026#34;在函数sqr内,形参对象ob的数据成员i的值为\u0026#34;\u0026lt;\u0026lt;ob.get()\u0026lt;\u0026lt;endl; } int main(){ Tr obj(10); cout\u0026lt;\u0026lt;\u0026#34;调用函数sqr前,实参i值为:\u0026#34;\u0026lt;\u0026lt;obj.get()\u0026lt;\u0026lt;endl; sqr(obj); cout\u0026lt;\u0026lt;\u0026#34;调用函数sqr后,实参i值为:\u0026#34;\u0026lt;\u0026lt;obj.get()\u0026lt;\u0026lt;endl; return 0; } output: 调用函数sqr前,实参i值为:10 在函数sqr内,形参对象ob的数据成员i的值为100 调用函数sqr后,实参i的值为:100\n对象赋值语句 # A和B是同一类的两个对象,那么下述对象赋值语句,就能把对象A的数据成员的值逐位复制给对象B B=A; 拷贝构造函数 #调用拷贝构造函数的形式 # 代入法 类名 对象2(对象1) 如: Point p2(p1); 赋值法 对象2=对象1; 如:Point p2=p1; 缺省拷贝构造函数 # 如果没有编写自定义的拷贝构造函数,C P P会自动地将一个已存在的对象复制给新对象 这种按成员逐一复制的过程是由缺省拷贝构造函数自动完成的 调用构造函数的3种情况 # 当用类的一个对象去初始化该类的另一个对象时,拷贝构造函数将会被调用 如: Point p2(p1); Point p2=p1; 当函数的形参是类的对象,在调用函数进行形参和实参结合时,拷贝函数将会被调用 void fun1(Point p) { p.print(); } int main() { Point p1(10,20); fun1(p1); return 0; } 当函数的返回值是类的对象,在函数调用完毕将返回值(对象)带回函数调用处时,此时就会调用拷贝构造函数,将此对象复制给一个临时对象并传到该函数的调用处 Point fun2() { Point p1(10,30); return p1; } int main() { Point p2; p2 = fun2(); return 0; } ","date":"24 April 2024","permalink":"/cpp/5/","section":"CPPs","summary":"","title":"string类-向函数传递对象-对象赋值语句-拷贝构造函数"},{"content":"类的构造函数和析构函数 #构造函数 # 构造函数的名字必须与类名相同，且不能有返回参数 class Complex{ Private: double real; double imag; Public: Complex(double r,double i) {real=r;imag=i;} }; 定义对象时，编译系统会自动调用构造函数~~（初始化）~~ 与普通成员函数一样，可以定义在体内也可以定义在体外 构造函数的主要作用是对对象进行初始化 构造函数一般声明为公有成员，但不能像其他成员一样被显式调用它在定义对象的同时被调用，且只调用一次 在实际应用中有通常要为每一个类定义构造函数 构造函数可以不带参数 构造函数可以重载 用成员初始化列表对数据成员初始化 # 一般表达形式 类名::构造函数名([参数表])[:(成员初始化列表)] {//构造函数体} 成员初始化列表一般形式 数据成员1(初始值1),数据成员2(初始值2),\u0026hellip;..\n析构函数 # 定义 是一种特殊的成员函数，与构造函数功能相反，它用来释放对象，即当删除对象前，回收储存空间并进行一些清理工作 性质 析构函数名称与类名相同，但它名称前面必须要加一个～ 析构函数没有返回值，也没有参数 当对象生命周期结束时，编译系统会自动调用析构函数 析构函数不能重载 对象数组 # 指每一数组元素都是对象的数组 定义形式 类名 数组名 [下标表达式] Complex com[10] 有几个数组元素就要调用几次构造函数 如果构造函数只有一个参数，在定义对象数组时可以直接在等号后面的花括号内提供实参 使用格式 数组名[下标].成员名 当类中有多个参数的构造函数时，则必须使用如下的形式进行对象数组的初始化 Complex com[3]={ //定义对象数组com Complex(1.1,2.2),//为第一个对象数组元素提供实参 Complex(3.3,4,4),//为第二个对象数组元素提供实参 Complex(5.5,6.6)//为第三个对象数组元素提供实参 }; 对象指针 # 在CPP中，可以直接引用对象，也可通过指向该对象的指针引用对象 exe ob; //定义类exe的对象ob exe *p; //定义指向类exe的对象指针p P=\u0026amp;ob;//将对象ob的地址赋给对象指针p 用对象指针访问对象数组 exe ob[2];//定义类exe的对象数组ob[2] exe *p;//定义指向类exe的对象指针p //数组名代表第一个元素的地址 P=ob; //将对象数组ob的地址赋给对象指针p this指针 # 在每个对象的数据成员中都有一个系统隐含的指针this 这个指针this的类型为这个对象所属类的类型 这个指针this的值为包含它的那个对象的首地址 ","date":"18 April 2024","permalink":"/cpp/4/","section":"CPPs","summary":"","title":"构造函数－成员列表－析构函数－对象数组和对象指针"},{"content":"","date":null,"permalink":"/tags/%E6%95%B0%E7%94%B5/","section":"Tags","summary":"","title":"数电"},{"content":"逻辑代数公式 # 分配律 \\(A\\cdot(B+C)=A\\cdot B+A\\cdot C\\) \\(A+B \\cdot C=(A+B)\\cdot(A+C)\\) 同一律 \\(A\\cdot A=A\\) \\( A+A=A \\) 德摩根定理 \\(\\overline{A\\cdot B}=\\overline{A}+\\overline{B}\\) \\(\\overline{A+B}=\\overline{A}\\cdot \\overline{B}\\) 还原律 \\(\\overline{\\overline{A}}=A\\) 若干常用公式 \\(A\\cdot B+A\\cdot \\overline{B}=A\\) \\(A+A\\cdot B=A\\) \\(A+\\overline{A}\\cdot B=A+B\\) \\(A\\cdot B+\\overline{A}\\cdot C+B\\cdot C=A\\cdot B+\\overline{A}\\cdot C\\) 逻辑函数的最简表达式 #最简与或式 # 定义: 乘积项的个数最少,每个乘积项中相乘的变量个数也最少的与或表达式,称为最简与或式 最简与非-与非式 # 定义: 非号个数最少,每个非号下面相乘的变量个数也最少的与非-与非式,称为最简与非-与非式 求法: 在最简与或表达式的基础上,两次取反,再用德摩根定理去掉下面的反号,便可得到 最简或与式 # 定义: 括号个数最少,每个括号中相加的变量的个数也最少的或与式,称为最简或与式 求法: 在反函数最简与或式的基础上,取反,再用德摩根定理去掉反号,便可得到函数的最简或与式 最简或非-或非式 # 定义:非号个数最少,每个非号下面相加的变量个数也最少的或非-或非式,称为最简或非-或非表达式 求法:在最简或与表达式的基础上,两次取反,再用德摩根定理去掉下面的反号,所得到的便是函数的最简或非-或非表达式 最简与或非表达式 # 定义:在非号下面相加的乘积项个数最少,每个乘积项中相乘的变量个数也最少的与或非式,称为最简与或非表达式 求法:在最简或非-或非式的基础上,用德摩根定理去掉大反号下面的小反号,便可得到函数的最简与或非表达式 逻辑函数表示方法 #真值表 # 把变量的各种可能取值与相应的函数值,以表格形式一一列举出来. 列写方法: 0、1两种取值,n个变量共有\\(2^n\\)种不同的取值,将他们按二进制数递增规律排列起来,同时在相应位置写上函数的值,便可得到逻辑函数的真值表 卡诺图 # 定义：一个逻辑函数的卡诺图就是将此函数的最小项表达式中的各项最小项相应地填入一个特定的方格图内，此方格图为卡诺图 特点：几何位置相邻的最小项在逻辑上也是相邻的。即相邻的两个最小项只有一个变量不同 注意 对于n个变量的逻辑函数有 2ⁿ个最小项 卡诺图相邻的数为格雷编码，即只有一位二进制数不同（01-\u0026gt;11-\u0026gt;10） 逻辑表达式 # 用与、或、非等运算表示函数中各个变量之间逻辑关系的代数式子,称为逻辑表达式 逻辑图 # 用基本和常用的逻辑符号表示函数表达式中各个变量的运算关系 波形图 # 反映输入和输出变量对应取值随时间按照一定规律变化的图形,就称为波形图,也称时间图 ","date":"1 April 2024","permalink":"/cpp/3/","section":"CPPs","summary":"","title":"逻辑代数公式及最简表达式"},{"content":"k## 作用域运算符::\n说明 # 如果两个变量同名,一个全局的,一个局部的,那么局部变量在其作用域内具有较高的优先级 联合 #声明 #union data { int i; double d; }x; 访问时 x.i x.d 无名联合 # 是cpp中的特殊联合,它在关键字union后面没有给出联合名,它可使一组数据共用同一内存地址 结构体对齐\n强制类型转换 # OLD int i =10; float x=(float)i; NEW int 1=10; float x=float(i); new与delete运算符 #C语言内存动态分配 #int *p; p=(int*)malloc(sizeof(int)); free(p); CPP语言动态分配 #int *p; p=new int; delete p; 用法 # 用new申请空间的格式 p = new type; 用delete释放所申请的空间格式 delete p; 特殊用法 # 用new分配内存的同时,可以用()指定其初始值,但不能为数组元素指定初值 int *p; p = new int(99); 用new建立多维数组类型的变量 p=new type[size][m][n]...[s]; int (*pi)[3][4]=new int [i*4][3][4]; 用new可为动态数组分配内存空间 p=new float[5]; p=new int[m]; p=new double[m+5*n]; new和delete应该配对使用 #引用(CPP独占) # 引用相当于为某个变量、常量、数组或对象起了一个别名 使用 # 如果引用不是用作函数的参数或返回值,则必须在说明时初始化 int i; int \u0026amp;j; j=i; is ERROR\nint i; int \u0026amp;j=i; is RIGHT\n不是任何类型的数据都可以引用 不允许建立void类型的引用 不允许建立引用的数组 不能建立引用的引用;不能建立指向引用的指针; ","date":"29 March 2024","permalink":"/cpp/2/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/","section":"CPPs","summary":"","title":"作用域运算符-联合-强转-内存动态分配-引用"},{"content":"逗号语句执行 #printf(\u0026quot;%d\u0026quot;,(int a=3*5,a*4,a+5));\noutput\u0026gt;:20 在这个 printf 语句中，a=3 * 5 , a * 4,a+5 是一个逗号表达式。逗号表达式会依次计算其内部的子表达式，并返回最后一个子表达式的值。但是，逗号表达式的一个重要特性是，它会保证所有的子表达式（从左到右）都会被求值，并且除了最后一个子表达式的结果都会被丢弃\n带有默认(缺省)参数的函数 # 缺省函数必须从左往右定义,并且在一个缺省参数的右边不能有未指定的缺省值的参数. 定义 # 在函数定义or函数声明中指定了初始值的参数称为默认参数 int special(int x=5,float y=5.3); 初始化 # 可定义为任意的初始化表达式,可以包含函数调用以及全局变量等 int fun (int w=sqrt(a),int x=a*a); 说明 # void fun(int w,int x=1 ,int y=1,int z=1) is RIGHT\nvoid fun(int w,int x=1 ,int y, int z=1) is ERROR\n规则 # 如果函数定义在前,函数调用在后,在函数定义处写默认值 如果函数调用在前,函数定义在后,在函数声明处写默认值,函数定义处不要写 函数重载与默认值 #说明 # 缺省函数必须从右往左定义,并且在一个缺省参数的右边不能有未指定的缺省值的参数 void fun(int w,int x ,int y=1 ); void fun(int w,int x ); 该段代码有歧义若参数为 2,3 以上两种方式均合适产生二义性导致报错 ","date":"28 March 2024","permalink":"/cpp/1/%E9%80%97%E5%8F%B7%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C-%E9%BB%98%E8%AE%A4%E5%80%BC%E7%9B%B8%E5%85%B3/","section":"CPPs","summary":"","title":"逗号语句执行-默认值相关-函数重载"},{"content":"面向对象语言特点 # 抽象 类 -\u0026gt; 抽象 对象 -\u0026gt; 具体 封装 成员变量(私) 成员函数(公) 继承 多态 cpp向下兼容c语言 #cpp中不允许/**/嵌套使用 #cout\u0026lt;\u0026lt;_LINE_\u0026lt;\u0026lt;~~; # 显示该语句位于源程序第几行 通常只有规模很小(一般为1~5条语句)而频繁使用函数才定义为内联函数 #输出长度与精度控制 ##include \u0026lt;iomainip\u0026gt; //std::setw cout\u0026lt;\u0026lt;setw(10);限制输出长度为10 cout\u0026lt;\u0026lt;setprecision(5)\u0026lt;\u0026lt;~;//限制输出精度 cout\u0026lt;\u0026lt;fixed;//用定点数表示法表示浮点数 cpp中函数可以重载.只要函数参数的类型不同,or参数的个数不同,或者二者兼而有之,两个or两个以上的函数可以使用相同的函数名 #指向常量的指针 #const char *name =\u0026quot;chen\u0026quot;;\n*name 是常量(name不允许改变) name[3]='a' ; is ERROR name是指向常量的指针变量(指针name本身可以改变) name =\u0026quot;zhang\u0026quot;; is RIGHT 指向字符串的常指针 #char* const name =\u0026quot;chen\u0026quot;;\nname是常量(name不允许改变) 指针的地址不允许改变 name = \u0026quot;zhang\u0026quot; is ERROR 指向常量的常指针 #const char* const name =\u0026quot;chen\u0026quot;;\n","date":"28 March 2024","permalink":"/cpp/cpp%E7%89%B9%E7%82%B9-%E8%BE%93%E5%87%BA%E9%95%BF%E5%BA%A6%E4%B8%8E%E7%B2%BE%E5%BA%A6%E6%8E%A7%E5%88%B6-%E6%8C%87%E9%92%88%E4%B8%8E%E5%B8%B8%E9%87%8F/","section":"CPPs","summary":"","title":"CPP特点-输出长度与精度控制-指针与常量"},{"content":"本博客由22年部署现迁移至github+hugo #原地址：https://emiya-omega.gitlab.io 警告! 本博客不针对移动端进行页面优化! ","date":"27 March 2024","permalink":"/posts/test/test/","section":"Posts","summary":"","title":"About"},{"content":"","date":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":null,"permalink":"/tags/%E4%BB%8B%E7%BB%8D/","section":"Tags","summary":"","title":"介绍"},{"content":"","date":null,"permalink":"/categories/%E6%9D%82%E6%96%87/","section":"Categories","summary":"","title":"杂文"}]